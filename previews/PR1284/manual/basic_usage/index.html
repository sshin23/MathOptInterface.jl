<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic usage · MathOptInterface</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MathOptInterface</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../background/motivation/">Motivation</a></li><li><a class="tocitem" href="../../background/duality/">Duality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li><li><a class="tocitem" href="../status/">Statuses</a></li><li><a class="tocitem" href="../modification/">Problem modification</a></li><li class="is-active"><a class="tocitem" href>Basic usage</a><ul class="internal"><li><a class="tocitem" href="#The-ModelLike-and-AbstractOptimizer-APIs"><span>The ModelLike and AbstractOptimizer APIs</span></a></li><li><a class="tocitem" href="#Add-a-variable"><span>Add a variable</span></a></li><li><a class="tocitem" href="#Delete-a-variable"><span>Delete a variable</span></a></li><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Solving-and-retrieving-the-results"><span>Solving and retrieving the results</span></a></li><li><a class="tocitem" href="#A-complete-example:-solving-a-knapsack-problem"><span>A complete example: solving a knapsack problem</span></a></li></ul></li><li><a class="tocitem" href="../implementing/">Implementing a solver interface</a></li></ul></li><li><a class="tocitem" href="../../reference/reference/">API Reference</a></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../submodules/Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox"/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Utilities/overview/">Overview</a></li><li><a class="tocitem" href="../../submodules/Utilities/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../submodules/Test/overview/">Overview</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Basic usage</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic usage</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/MathOptInterface.jl/blob/master/docs/src/manual/basic_usage.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>MOI does not export functions, but for brevity we often omit qualifying names with the MOI module. Best practice is to have</p><pre><code class="language-julia">using MathOptInterface
const MOI = MathOptInterface</code></pre><p>and prefix all MOI methods with <code>MOI.</code> in user code. If a name is also available in base Julia, we always explicitly use the module prefix, for example, with <code>MOI.get</code>.</p></div></div><h2 id="The-ModelLike-and-AbstractOptimizer-APIs"><a class="docs-heading-anchor" href="#The-ModelLike-and-AbstractOptimizer-APIs">The ModelLike and AbstractOptimizer APIs</a><a id="The-ModelLike-and-AbstractOptimizer-APIs-1"></a><a class="docs-heading-anchor-permalink" href="#The-ModelLike-and-AbstractOptimizer-APIs" title="Permalink"></a></h2><p>The most significant part of MOI is the definition of the <strong>model API</strong> that is used to specify an instance of an optimization problem (e.g., by adding variables and constraints). Objects that implement the model API should inherit from the <a href="../../reference/reference/#MathOptInterface.ModelLike"><code>ModelLike</code></a> abstract type.</p><p>Notably missing from the model API is the method to solve an optimization problem. <code>ModelLike</code> objects may store an instance (e.g., in memory or backed by a file format) without being linked to a particular solver. In addition to the model API, MOI defines <a href="../../reference/reference/#MathOptInterface.AbstractOptimizer"><code>AbstractOptimizer</code></a>.</p><p><em>Optimizers</em> (or solvers) implement the model API (inheriting from <code>ModelLike</code>) and additionally provide methods to solve the model.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>Throughout the rest of the manual, <code>model</code> is used as a generic <code>ModelLike</code>, and <code>optimizer</code> is used as a generic <code>AbstractOptimizer</code>.</p></div></div><p>Models are constructed by</p><ul><li>adding variables using <a href="../../reference/reference/#MathOptInterface.add_variable"><code>add_variable</code></a> (or <a href="../../reference/reference/#MathOptInterface.add_variables"><code>add_variables</code></a>), see <a href="#Add-a-variable">Add a variable</a>;</li><li>setting an objective sense and function using <a href="../../reference/reference/#MathOptInterface.set"><code>set</code></a>, see <a href="#Setting-an-objective">Setting an objective</a>;</li><li>and adding constraints using <a href="../../reference/reference/#MathOptInterface.add_constraint"><code>add_constraint</code></a> (or <a href="../../reference/reference/#MathOptInterface.add_constraints"><code>add_constraints</code></a>), see <a href="../constraints/#Constraints">Constraints</a>.</li></ul><p>The way the problem is solved by the optimimizer is controlled by <a href="../../reference/reference/#MathOptInterface.AbstractOptimizerAttribute"><code>AbstractOptimizerAttribute</code></a>s, see <a href="../implementing/#Solver-specific-attributes">Solver-specific attributes</a>.</p><h2 id="Add-a-variable"><a class="docs-heading-anchor" href="#Add-a-variable">Add a variable</a><a id="Add-a-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Add-a-variable" title="Permalink"></a></h2><p>All variables in MOI are scalar variables. New scalar variables are created with <a href="../../reference/reference/#MathOptInterface.add_variable"><code>add_variable</code></a> or <a href="../../reference/reference/#MathOptInterface.add_variables"><code>add_variables</code></a>, which return a <a href="../../reference/reference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> or <code>Vector{VariableIndex}</code> respectively. <a href="../../reference/reference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> objects are type-safe wrappers around integers that refer to a variable in a particular model.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The integer does not necessarily corresond to the column inside an optimizer!</p></div></div><p>One uses <a href="../../reference/reference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> objects to set and get variable attributes. For example, the <a href="../../reference/reference/#MathOptInterface.VariablePrimalStart"><code>VariablePrimalStart</code></a> attribute is used to provide an initial starting point for a variable or collection of variables:</p><pre><code class="language-julia">v = MOI.add_variable(model)
MOI.set(model, MOI.VariablePrimalStart(), v, 10.5)
v2 = MOI.add_variables(model, 3)
MOI.set(model, MOI.VariablePrimalStart(), v2, [1.3, 6.8, -4.6])</code></pre><h2 id="Delete-a-variable"><a class="docs-heading-anchor" href="#Delete-a-variable">Delete a variable</a><a id="Delete-a-variable-1"></a><a class="docs-heading-anchor-permalink" href="#Delete-a-variable" title="Permalink"></a></h2><p>Delete a variable using <a href="../../reference/reference/#MathOptInterface.delete-Tuple{MathOptInterface.ModelLike,Union{VariableIndex, ConstraintIndex}}"><code>delete(::ModelLike, ::VariableIndex)</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Not all <code>ModelLike</code> models support deleting variables. A <a href="../../reference/reference/#MathOptInterface.DeleteNotAllowed"><code>DeleteNotAllowed</code></a> error is thrown if this is not supported.</p></div></div><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><p>MOI defines six functions as listed in the definition of the <a href="../standard_form/#Standard-form-problem">Standard form problem</a>. The simplest function is <a href="../../reference/reference/#MathOptInterface.SingleVariable"><code>SingleVariable</code></a>, defined as:</p><pre><code class="language-julia">struct SingleVariable &lt;: AbstractFunction
    variable::VariableIndex
end</code></pre><p>If <code>v</code> is a <a href="../../reference/reference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> object, then <code>SingleVariable(v)</code> is simply the scalar-valued function from the complete set of variables in a model that returns the value of variable <code>v</code>. One may also call this function a coordinate projection, which is more useful for defining constraints than as an objective function.</p><p>A more interesting function is <a href="../../reference/reference/#MathOptInterface.ScalarAffineFunction"><code>ScalarAffineFunction</code></a>, defined as:</p><pre><code class="language-julia">struct ScalarAffineFunction{T} &lt;: AbstractScalarFunction
    terms::Vector{ScalarAffineTerm{T}}
    constant::T
end</code></pre><p>The <a href="../../reference/reference/#MathOptInterface.ScalarAffineTerm"><code>ScalarAffineTerm</code></a> struct defines a variable-coefficient pair:</p><pre><code class="language-julia">struct ScalarAffineTerm{T}
    coefficient::T
    variable_index::VariableIndex
end</code></pre><p>If <code>x</code> is a vector of <code>VariableIndex</code> objects, then</p><pre><code class="language-julia">MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([5.0, -2.3], [x[1], x[2]]), 1.0)</code></pre><p>represents the function <span>$5 x_1 - 2.3 x_2 + 1$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>MOI.ScalarAffineTerm.([5.0, -2.3], [x[1], x[2]])</code> is a shortcut for <code>[MOI.ScalarAffineTerm(5.0, x[1]), MOI.ScalarAffineTerm(-2.3, x[2])]</code>. This is Julia&#39;s broadcast syntax in action, and is used quite often.</p></div></div><h3 id="Setting-an-objective"><a class="docs-heading-anchor" href="#Setting-an-objective">Setting an objective</a><a id="Setting-an-objective-1"></a><a class="docs-heading-anchor-permalink" href="#Setting-an-objective" title="Permalink"></a></h3><p>Objective functions are assigned to a model by setting the <a href="../../reference/reference/#MathOptInterface.ObjectiveFunction"><code>ObjectiveFunction</code></a> attribute. The <a href="../../reference/reference/#MathOptInterface.ObjectiveSense"><code>ObjectiveSense</code></a> attribute is used for setting the optimization sense. For example,</p><pre><code class="language-julia">x = MOI.add_variables(model, 2)
MOI.set(
    model,
    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),
    MOI.ScalarAffineFunction(
        MOI.ScalarAffineTerm.([5.0, -2.3], [x[1], x[2]]), 1.0),
    )
MOI.set(model, MOI.ObjectiveSense(), MIN_SENSE)</code></pre><p>sets the objective to the function just discussed in the minimization sense.</p><p>See <a href="../../reference/reference/#Functions-and-function-modifications">Functions and function modifications</a> for the complete list of functions.</p><h2 id="Solving-and-retrieving-the-results"><a class="docs-heading-anchor" href="#Solving-and-retrieving-the-results">Solving and retrieving the results</a><a id="Solving-and-retrieving-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-and-retrieving-the-results" title="Permalink"></a></h2><p>Once an optimizer is loaded with the objective function and all of the constraints, we can ask the solver to solve the model by calling <a href="../../reference/reference/#MathOptInterface.optimize!"><code>optimize!</code></a>.</p><pre><code class="language-julia">MOI.optimize!(optimizer)</code></pre><p>The optimization procedure may terminate for a number of reasons. The <a href="../../reference/reference/#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> attribute of the optimizer returns a <a href="../../reference/reference/#MathOptInterface.TerminationStatusCode"><code>TerminationStatusCode</code></a> object which explains why the solver stopped. The termination statuses distinguish between proofs of optimality, infeasibility, local convergence, limits, and termination because of something unexpected like invalid problem data or failure to converge. A typical usage of the <a href="../../reference/reference/#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a> attribute is as follows:</p><pre><code class="language-julia">status = MOI.get(optimizer, TerminationStatus())
if status == MOI.OPTIMAL
    # Ok, we solved the problem!
else
    # Handle other cases.
end</code></pre><p>After checking the <a href="../../reference/reference/#MathOptInterface.TerminationStatus"><code>TerminationStatus</code></a>, one should typically check <a href="../../reference/reference/#MathOptInterface.ResultCount"><code>ResultCount</code></a>. This attribute returns the number of results that the solver has available to return. <em>A result is defined as a primal-dual pair, but either the primal or the dual may be missing from the result.</em> While the <code>OPTIMAL</code> termination status normally implies that at least one result is available, other statuses do not. For example, in the case of infeasiblity, a solver may return no result or a proof of infeasibility. The <a href="../../reference/reference/#MathOptInterface.ResultCount"><code>ResultCount</code></a> attribute distinguishes between these two cases.</p><p>The <a href="../../reference/reference/#MathOptInterface.PrimalStatus"><code>PrimalStatus</code></a> and <a href="../../reference/reference/#MathOptInterface.DualStatus"><code>DualStatus</code></a> attributes return a <a href="../../reference/reference/#MathOptInterface.ResultStatusCode"><code>ResultStatusCode</code></a> that indicates if that component of the result is present (i.e., not <code>NO_SOLUTION</code>) and explains how to interpret the result.</p><p>If <code>PrimalStatus</code> is not <code>NO_SOLUTION</code>, then the primal may be retrieved with the <a href="../../reference/reference/#MathOptInterface.VariablePrimal"><code>VariablePrimal</code></a> attribute:</p><pre><code class="language-julia">MOI.get(optimizer, VariablePrimal(), x)</code></pre><p>If <code>x</code> is a <a href="../../reference/reference/#MathOptInterface.VariableIndex"><code>VariableIndex</code></a> then the function call returns a scalar, and if <code>x</code> is a <code>Vector{VariableIndex}</code> then the call returns a vector of scalars. <code>VariablePrimal()</code> is equivalent to <code>VariablePrimal(1)</code>, i.e., the variable primal vector of the first result. Use <code>VariablePrimal(N)</code> to access the <code>N</code>th result.</p><p>See also the attributes <a href="../../reference/reference/#MathOptInterface.ConstraintPrimal"><code>ConstraintPrimal</code></a>, and <a href="../../reference/reference/#MathOptInterface.ConstraintDual"><code>ConstraintDual</code></a>.</p><p>See <a href="../../background/duality/#Duality">Duality</a> for a discussion of the MOI conventions for primal-dual pairs and certificates.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We omit discussion of how to handle multiple results, i.e., when <code>ResultCount</code> is greater than 1. This is supported in the API but not yet implemented in any solver.</p></div></div><h3 id="Common-status-situations"><a class="docs-heading-anchor" href="#Common-status-situations">Common status situations</a><a id="Common-status-situations-1"></a><a class="docs-heading-anchor-permalink" href="#Common-status-situations" title="Permalink"></a></h3><p>The sections below describe how to interpret typical or interesting status cases for three common classes of solvers. The example cases are illustrative, not comprehensive. Solver wrappers may provide additional information on how the solver&#39;s statuses map to MOI statuses.</p><p><code>?</code> in the tables indicate that multiple different values are possible.</p><h4 id="Primal-dual-convex-solver"><a class="docs-heading-anchor" href="#Primal-dual-convex-solver">Primal-dual convex solver</a><a id="Primal-dual-convex-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Primal-dual-convex-solver" title="Permalink"></a></h4><p>Linear programming and conic optimization solvers fall into this category.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Proved optimality</td><td style="text-align: right"><code>OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Proved infeasible</td><td style="text-align: right"><code>INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>INFEASIBILITY_CERTIFICATE</code></td></tr><tr><td style="text-align: right">Optimal within relaxed tolerances</td><td style="text-align: right"><code>ALMOST_OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code> or <code>ALMOST_FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code> or <code>ALMOST_FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Detected an unbounded ray of the primal</td><td style="text-align: right"><code>DUAL_INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBILITY_CERTIFICATE</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Stall</td><td style="text-align: right"><code>SLOW_PROGRESS</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr></table><h4 id="Global-branch-and-bound-solvers"><a class="docs-heading-anchor" href="#Global-branch-and-bound-solvers">Global branch-and-bound solvers</a><a id="Global-branch-and-bound-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Global-branch-and-bound-solvers" title="Permalink"></a></h4><p>Mixed-integer programming solvers fall into this category.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Proved optimality</td><td style="text-align: right"><code>OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Presolve detected infeasibility or unboundedness</td><td style="text-align: right"><code>INFEASIBLE_OR_UNBOUNDED</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Proved infeasibility</td><td style="text-align: right"><code>INFEASIBLE</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Timed out (no solution)</td><td style="text-align: right"><code>TIME_LIMIT</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Timed out (with a solution)</td><td style="text-align: right"><code>TIME_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right"><code>CPXMIP_OPTIMAL_INFEAS</code></td><td style="text-align: right"><code>ALMOST_OPTIMAL</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBLE_POINT</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr></table><p><a href="https://www.ibm.com/support/knowledgecenter/en/SSSA5P_12.6.1/ilog.odms.cplex.help/refcallablelibrary/macros/CPXMIP_OPTIMAL_INFEAS.html"><code>CPXMIP_OPTIMAL_INFEAS</code></a> is a CPLEX status that indicates that a preprocessed problem was solved to optimality, but the solver was unable to recover a feasible solution to the original problem.</p><h4 id="Local-search-solvers"><a class="docs-heading-anchor" href="#Local-search-solvers">Local search solvers</a><a id="Local-search-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Local-search-solvers" title="Permalink"></a></h4><p>Nonlinear programming solvers fall into this category. It also includes non-global tree search solvers like <a href="https://github.com/lanl-ansi/Juniper.jl">Juniper</a>.</p><table><tr><th style="text-align: right">What happened?</th><th style="text-align: right"><code>TerminationStatus()</code></th><th style="text-align: right"><code>ResultCount()</code></th><th style="text-align: right"><code>PrimalStatus()</code></th><th style="text-align: right"><code>DualStatus()</code></th></tr><tr><td style="text-align: right">Converged to a stationary point</td><td style="text-align: right"><code>LOCALLY_SOLVED</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Completed a non-global tree search (with a solution)</td><td style="text-align: right"><code>LOCALLY_SOLVED</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>FEASIBLE_POINT</code></td><td style="text-align: right"><code>FEASIBLE_POINT</code></td></tr><tr><td style="text-align: right">Converged to an infeasible point</td><td style="text-align: right"><code>LOCALLY_INFEASIBLE</code></td><td style="text-align: right">1</td><td style="text-align: right"><code>INFEASIBLE_POINT</code></td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Completed a non-global tree search (no solution found)</td><td style="text-align: right"><code>LOCALLY_INFEASIBLE</code></td><td style="text-align: right">0</td><td style="text-align: right"><code>NO_SOLUTION</code></td><td style="text-align: right"><code>NO_SOLUTION</code></td></tr><tr><td style="text-align: right">Iteration limit</td><td style="text-align: right"><code>ITERATION_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr><tr><td style="text-align: right">Diverging iterates</td><td style="text-align: right"><code>NORM_LIMIT</code> or <code>OBJECTIVE_LIMIT</code></td><td style="text-align: right">1</td><td style="text-align: right">?</td><td style="text-align: right">?</td></tr></table><h2 id="A-complete-example:-solving-a-knapsack-problem"><a class="docs-heading-anchor" href="#A-complete-example:-solving-a-knapsack-problem">A complete example: solving a knapsack problem</a><a id="A-complete-example:-solving-a-knapsack-problem-1"></a><a class="docs-heading-anchor-permalink" href="#A-complete-example:-solving-a-knapsack-problem" title="Permalink"></a></h2><p>We first need to select a solver supporting the given problem (see <a href="../../reference/reference/#MathOptInterface.supports"><code>supports</code></a> and <a href="../../reference/reference/#MathOptInterface.supports_constraint"><code>supports_constraint</code></a>). In this example, we want to solve a binary-constrained knapsack problem: <code>max c&#39;x: w&#39;x &lt;= C, x binary</code>. Suppose we choose GLPK:</p><pre><code class="language-julia">using GLPK
optimizer = GLPK.Optimizer()</code></pre><p>We first define the constants of the problem:</p><pre><code class="language-julia">c = [1.0, 2.0, 3.0]
w = [0.3, 0.5, 1.0]
C = 3.2

# output

3.2</code></pre><p>We create the variables of the problem and set the objective function:</p><pre><code class="language-julia">x = MOI.add_variables(optimizer, length(c))
MOI.set(
    optimizer,
    MOI.ObjectiveFunction{MOI.ScalarAffineFunction{Float64}}(),
    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(c, x), 0.0),
)
MOI.set(optimizer, MOI.ObjectiveSense(), MOI.MAX_SENSE)

# output
</code></pre><p>We add the knapsack constraint and integrality constraints:</p><pre><code class="language-julia">MOI.add_constraint(
    optimizer,
    MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.(w, x), 0.0),
    MOI.LessThan(C),
)
for x_i in x
    MOI.add_constraint(optimizer, MOI.SingleVariable(x_i), MOI.ZeroOne())
end

# output
</code></pre><p>We are all set! We can now call <a href="../../reference/reference/#MathOptInterface.optimize!"><code>optimize!</code></a> and wait for the solver to find the solution:</p><pre><code class="language-julia">MOI.optimize!(optimizer)

# output
</code></pre><p>The first thing to check after optimization is why the solver stopped, e.g., did it stop because of a time limit or did it stop because it found the optimal solution?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.TerminationStatus())

# output


OPTIMAL::TerminationStatusCode = 1</code></pre><p>It found the optimal solution! Now let&#39;s see what is that solution.</p><pre><code class="language-julia">MOI.get(optimizer, MOI.PrimalStatus())

# output

FEASIBLE_POINT::ResultStatusCode = 1</code></pre><p>What is its objective value?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.ObjectiveValue())

# output

6.0</code></pre><p>And what is the value of the variables <code>x</code>?</p><pre><code class="language-julia">MOI.get(optimizer, MOI.VariablePrimal(), x)

# output

3-element Array{Float64,1}:
 1.0
 1.0
 1.0</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../modification/">« Problem modification</a><a class="docs-footer-nextpage" href="../implementing/">Implementing a solver interface »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 11 March 2021 19:42">Thursday 11 March 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
