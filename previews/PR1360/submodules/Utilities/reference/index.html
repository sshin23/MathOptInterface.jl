<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MathOptInterface</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MathOptInterface</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Background</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../background/motivation/">Motivation</a></li><li><a class="tocitem" href="../../../background/duality/">Duality</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/standard_form/">Standard form problem</a></li><li><a class="tocitem" href="../../../manual/models/">Models</a></li><li><a class="tocitem" href="../../../manual/variables/">Variables</a></li><li><a class="tocitem" href="../../../manual/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../manual/solutions/">Solutions</a></li><li><a class="tocitem" href="../../../manual/modification/">Problem modification</a></li><li><a class="tocitem" href="../../../manual/example/">A complete example: solving a knapsack problem</a></li><li><a class="tocitem" href="../../../manual/implementing/">Implementing a solver interface</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">API Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../reference/standard_form/">Standard form</a></li><li><a class="tocitem" href="../../../reference/models/">Models</a></li><li><a class="tocitem" href="../../../reference/variables/">Variables</a></li><li><a class="tocitem" href="../../../reference/constraints/">Constraints</a></li><li><a class="tocitem" href="../../../reference/modification/">Modifications</a></li><li><a class="tocitem" href="../../../reference/nonlinear/">Nonlinear programming</a></li><li><a class="tocitem" href="../../../reference/callbacks/">Callbacks</a></li><li><a class="tocitem" href="../../../reference/errors/">Errors</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox" checked/><label class="tocitem" for="menuitem-5"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-5-1" type="checkbox"/><label class="tocitem" for="menuitem-5-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-2" type="checkbox"/><label class="tocitem" for="menuitem-5-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../Bridges/implementation/">Implementation</a></li><li><a class="tocitem" href="../../Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-3" type="checkbox"/><label class="tocitem" for="menuitem-5-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-4" type="checkbox" checked/><label class="tocitem" for="menuitem-5-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Utilities.Model"><span>Utilities.Model</span></a></li><li><a class="tocitem" href="#Utilities.UniversalFallback"><span>Utilities.UniversalFallback</span></a></li><li><a class="tocitem" href="#Utilities.@macro"><span>Utilities.@macro</span></a></li><li><a class="tocitem" href="#Printing"><span>Printing</span></a></li><li><a class="tocitem" href="#Copy-utilities"><span>Copy utilities</span></a></li><li><a class="tocitem" href="#Utilities.MatrixOfConstraints"><span>Utilities.MatrixOfConstraints</span></a></li><li><a class="tocitem" href="#Fallbacks"><span>Fallbacks</span></a></li><li><a class="tocitem" href="#Function-utilities"><span>Function utilities</span></a></li><li><a class="tocitem" href="#Constraint-utilities"><span>Constraint utilities</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-5-5" type="checkbox"/><label class="tocitem" for="menuitem-5-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Utilities</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/MathOptInterface.jl/blob/master/docs/src/submodules/Utilities/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Utilities.Model"><a class="docs-heading-anchor" href="#Utilities.Model">Utilities.Model</a><a id="Utilities.Model-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.Model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Model" href="#MathOptInterface.Utilities.Model"><code>MathOptInterface.Utilities.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <code>ModelLike</code> that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.</p><p><strong>Examples</strong></p><pre><code class="language-jl">model = Model{Float64}()
x = add_variable(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/model.jl#L1175-L1185">source</a></section></article><h2 id="Utilities.UniversalFallback"><a class="docs-heading-anchor" href="#Utilities.UniversalFallback">Utilities.UniversalFallback</a><a id="Utilities.UniversalFallback-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.UniversalFallback" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.UniversalFallback" href="#MathOptInterface.Utilities.UniversalFallback"><code>MathOptInterface.Utilities.UniversalFallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniversalFallback</code></pre><p>The <code>UniversalFallback</code> can be applied on a <a href="../../../reference/models/#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> <code>model</code> to create the model <code>UniversalFallback(model)</code> supporting <em>any</em> constraint and attribute. This allows to have a specialized implementation in <code>model</code> for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that <code>model</code> is unaware of constraints and attributes stored by <code>UniversalFallback</code> so this is not appropriate if <code>model</code> is an optimizer (for this reason, <a href="../../../reference/models/#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> has not been implemented). In that case, optimizer bridges should be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/universalfallback.jl#L1-L13">source</a></section></article><h2 id="Utilities.@macro"><a class="docs-heading-anchor" href="#Utilities.@macro">Utilities.@macro</a><a id="Utilities.@macro-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.@macro" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@model" href="#MathOptInterface.Utilities.@model"><code>MathOptInterface.Utilities.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro model(
    model_name,
    scalar_sets,
    typed_scalar_sets,
    vector_sets,
    typed_vector_sets,
    scalar_functions,
    typed_scalar_functions,
    vector_functions,
    typed_vector_functions,
    is_optimizer = false
)</code></pre><p>Creates a type <code>model_name</code> implementing the MOI model interface and containing <code>scalar_sets</code> scalar sets <code>typed_scalar_sets</code> typed scalar sets, <code>vector_sets</code> vector sets, <code>typed_vector_sets</code> typed vector sets, <code>scalar_functions</code> scalar functions, <code>typed_scalar_functions</code> typed scalar functions, <code>vector_functions</code> vector functions and <code>typed_vector_functions</code> typed vector functions. To give no set/function, write <code>()</code>, to give one set <code>S</code>, write <code>(S,)</code>.</p><p>The function <a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> should not be given in <code>scalar_functions</code>. The model supports <a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<code>S</code> constraints where <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a>. The sets supported with the <a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> cannot be controlled from the macro, use the <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a> to support more sets.</p><p>This macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a>.</p><p>If <code>is_optimizer = true</code>, the resulting struct is a of <a href="#MathOptInterface.Utilities.GenericOptimizer"><code>GenericOptimizer</code></a>, which is a subtype of <a href="../../../reference/models/#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a>, otherwise, it is a <a href="#MathOptInterface.Utilities.GenericModel"><code>GenericModel</code></a>, which is a subtype of <a href="../../../reference/models/#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a>.</p><p><strong>Examples</strong></p><p>The model describing an linear program would be:</p><pre><code class="language-julia">@model(LPModel,                                                   # Name of model
      (),                                                         # untyped scalar sets
      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets
      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets
      (),                                                         #   typed vector sets
      (),                                                         # untyped scalar functions
      (MOI.ScalarAffineFunction,),                                #   typed scalar functions
      (MOI.VectorOfVariables,),                                   # untyped vector functions
      (MOI.VectorAffineFunction,),                                #   typed vector functions
      false
    )</code></pre><p>Let <code>MOI</code> denote <code>MathOptInterface</code>, <code>MOIU</code> denote <code>MOI.Utilities</code>. The macro would create the following types with <a href="#MathOptInterface.Utilities.struct_of_constraint_code"><code>struct_of_constraint_code</code></a>:</p><pre><code class="language-julia">struct LPModelScalarConstraints{T, C1, C2, C3, C4} &lt;: MOIU.StructOfConstraints
    moi_equalto::C1
    moi_greaterthan::C2
    moi_lessthan::C3
    moi_interval::C4
end
struct LPModelVectorConstraints{T, C1, C2, C3} &lt;: MOIU.StructOfConstraints
    moi_zeros::C1
    moi_nonnegatives::C2
    moi_nonpositives::C3
end
struct LPModelFunctionConstraints{T} &lt;: MOIU.StructOfConstraints
    moi_scalaraffinefunction::LPModelScalarConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.EqualTo{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.GreaterThan{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.LessThan{T}},
        MOIU.VectorOfConstraints{MOI.ScalarAffineFunction{T}, MOI.Interval{T}}
    }
    moi_vectorofvariables::LPModelVectorConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Zeros},
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonnegatives},
        MOIU.VectorOfConstraints{MOI.VectorOfVariables, MOI.Nonpositives}
    }
    moi_vectoraffinefunction::LPModelVectorConstraints{
        T,
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Zeros},
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonnegatives},
        MOIU.VectorOfConstraints{MOI.VectorAffineFunction{T}, MOI.Nonpositives}
    }
end
const LPModel{T} = MOIU.GenericModel{T, LPModelFunctionConstraints{T}}</code></pre><p>The type <code>LPModel</code> implements the MathOptInterface API except methods specific to optimizers like <code>optimize!</code> or <code>get</code> with <code>VariablePrimal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/model.jl#L866-L965">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.GenericModel" href="#MathOptInterface.Utilities.GenericModel"><code>MathOptInterface.Utilities.GenericModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct GenericModel{T,C} &lt;: AbstractModelLike{T}</code></pre><p>Implements a models supporting</p><ul><li>an objective function of type <code>MOI.SingleVariable</code>, <code>MOI.ScalarAffineFunction{T}</code> and <code>MOI.ScalarQuadraticFunction{T}</code>,</li><li><a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<code>S</code> constraints where <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a>.</li><li><code>F</code>-in-<code>S</code> constraints that are supported by <code>C</code>.</li></ul><p>The lower (resp. upper) bound of a variable of index <code>VariableIndex(i)</code> is at the <code>i</code>th index of the vector stored in the field <code>lower_bound</code> (resp. <code>upper_bound</code>). When no lower (resp. upper) bound is set, it is <code>typemin(T)</code> (resp. <code>typemax(T)</code>) if <code>T &lt;: AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/model.jl#L1046-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.GenericOptimizer" href="#MathOptInterface.Utilities.GenericOptimizer"><code>MathOptInterface.Utilities.GenericOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct GenericOptimizer{T,C} &lt;: AbstractOptimizer{T}</code></pre><p>Implements a models supporting</p><ul><li>an objective function of type <code>MOI.SingleVariable</code>, <code>MOI.ScalarAffineFunction{T}</code> and <code>MOI.ScalarQuadraticFunction{T}</code>,</li><li><a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<code>S</code> constraints where <code>S</code> is <a href="../../../reference/standard_form/#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a>, <a href="../../../reference/standard_form/#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a>.</li><li><code>F</code>-in-<code>S</code> constraints that are supported by <code>C</code>.</li></ul><p>The lower (resp. upper) bound of a variable of index <code>VariableIndex(i)</code> is at the <code>i</code>th index of the vector stored in the field <code>lower_bound</code> (resp. <code>upper_bound</code>). When no lower (resp. upper) bound is set, it is <code>typemin(T)</code> (resp. <code>typemax(T)</code>) if <code>T &lt;: AbstractFloat</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/model.jl#L1046-L1065">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.struct_of_constraint_code" href="#MathOptInterface.Utilities.struct_of_constraint_code"><code>MathOptInterface.Utilities.struct_of_constraint_code</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">struct_of_constraint_code(struct_name, types, field_types = nothing)</code></pre><p>Given a vector of <code>n</code> <code>SymbolFun</code> or <code>SymbolSet</code> in <code>types</code>, creates a struct of name <code>struct_name</code> that is a subtype of <code>StructOfConstraint{T, C1, C2, ..., Cn}</code> if <code>field_types</code> is <code>nothing</code> and a subtype of <code>StructOfConstraint{T}</code> otherwise. It contains <code>n</code> field where the <code>i</code>th field has type <code>Ci</code> if <code>field_types</code> is <code>nothing</code> and type <code>field_types[i]</code> otherwise. If <code>types</code> is vector of <code>SymbolFun</code> (resp. <code>SymbolSet</code>) then the constraints of that function (resp. set) type are stored in the corresponding field.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/struct_of_constraints.jl#L198-L209">source</a></section></article><h3 id="Caching-optimizer"><a class="docs-heading-anchor" href="#Caching-optimizer">Caching optimizer</a><a id="Caching-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Caching-optimizer" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.CachingOptimizer" href="#MathOptInterface.Utilities.CachingOptimizer"><code>MathOptInterface.Utilities.CachingOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachingOptimizer</code></pre><p><code>CachingOptimizer</code> is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn&#39;t.</p><p>A <code>CachingOptimizer</code> may be in one of three possible states (<code>CachingOptimizerState</code>):</p><ul><li><code>NO_OPTIMIZER</code>: The CachingOptimizer does not have any optimizer.</li><li><code>EMPTY_OPTIMIZER</code>: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.</li><li><code>ATTACHED_OPTIMIZER</code>: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.</li></ul><p>A <code>CachingOptimizer</code> has two modes of operation (<code>CachingOptimizerMode</code>):</p><ul><li><code>MANUAL</code>: The only methods that change the state of the <code>CachingOptimizer</code> are <a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a>, <a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a>, and <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>. Attempting to perform an operation in the incorrect state results in an error.</li><li><code>AUTOMATIC</code>: The <code>CachingOptimizer</code> changes its state when necessary. For example, <code>optimize!</code> will automatically call <code>attach_optimizer</code> (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to <code>EMPTY_OPTIMIZER</code> mode.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L14-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.attach_optimizer" href="#MathOptInterface.Utilities.attach_optimizer"><code>MathOptInterface.Utilities.attach_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attach_optimizer(model::CachingOptimizer)</code></pre><p>Attaches the optimizer to <code>model</code>, copying all model data into it. Can be called only from the <code>EMPTY_OPTIMIZER</code> state. If the copy succeeds, the <code>CachingOptimizer</code> will be in state <code>ATTACHED_OPTIMIZER</code> after the call, otherwise an error is thrown; see <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> for more details on which errors can be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L180-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.reset_optimizer" href="#MathOptInterface.Utilities.reset_optimizer"><code>MathOptInterface.Utilities.reset_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)</code></pre><p>Sets or resets <code>m</code> to have the given empty optimizer <code>optimizer</code>.</p><p>Can be called from any state. An assertion error will be thrown if <code>optimizer</code> is not empty.</p><p>The <code>CachingOptimizer</code> <code>m</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L121-L130">source</a></section><section><div><pre><code class="language-none">reset_optimizer(m::CachingOptimizer)</code></pre><p>Detaches and empties the current optimizer. Can be called from <code>ATTACHED_OPTIMIZER</code> or <code>EMPTY_OPTIMIZER</code> state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L153-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.drop_optimizer" href="#MathOptInterface.Utilities.drop_optimizer"><code>MathOptInterface.Utilities.drop_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drop_optimizer(m::CachingOptimizer)</code></pre><p>Drops the optimizer, if one is present. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>NO_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L168-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.state" href="#MathOptInterface.Utilities.state"><code>MathOptInterface.Utilities.state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">state(m::CachingOptimizer)::CachingOptimizerState</code></pre><p>Returns the state of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L107-L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.mode" href="#MathOptInterface.Utilities.mode"><code>MathOptInterface.Utilities.mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mode(m::CachingOptimizer)::CachingOptimizerMode</code></pre><p>Returns the operating mode of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/cachingoptimizer.jl#L114-L118">source</a></section></article><h2 id="Printing"><a class="docs-heading-anchor" href="#Printing">Printing</a><a id="Printing-1"></a><a class="docs-heading-anchor-permalink" href="#Printing" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.latex_formulation" href="#MathOptInterface.Utilities.latex_formulation"><code>MathOptInterface.Utilities.latex_formulation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">latex_formulation(model::MOI.ModelLike; kwargs...)</code></pre><p>Wrap <code>model</code> in a type so that it can be pretty-printed as <code>text/latex</code> in a notebook like IJulia, or in Documenter.</p><p>To render the model, end the cell with <code>latex_formulation(model)</code>, or call <code>display(latex_formulation(model))</code> in to force the display of the model from inside a function.</p><p>Possible keyword arguments are:</p><ul><li><code>simplify_coefficients</code> : Simplify coefficients if possible by omitting them or removing trailing zeros.</li><li><code>default_name</code> : The name given to variables with an empty name.</li><li><code>print_types</code> : Print the MOI type of each function and set for clarity.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/print.jl#L608-L624">source</a></section></article><h2 id="Copy-utilities"><a class="docs-heading-anchor" href="#Copy-utilities">Copy utilities</a><a id="Copy-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-utilities" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.automatic_copy_to" href="#MathOptInterface.Utilities.automatic_copy_to"><code>MathOptInterface.Utilities.automatic_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">automatic_copy_to(
    dest::MOI.ModelLike,
    src::MOI.ModelLike;
    copy_names::Bool=true,
    filter_constraints::Union{Nothing,Function} = nothing,
)</code></pre><p>Use <a href="../../../reference/models/#MathOptInterface.supports_incremental_interface"><code>MathOptInterface.supports_incremental_interface</code></a> and <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> to automatically choose between <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> or <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> to apply the copy operation.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.default_copy_to" href="#MathOptInterface.Utilities.default_copy_to"><code>MathOptInterface.Utilities.default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_copy_to(
    dest::MOI.ModelLike,
    src::MOI.ModelLike,
    copy_names::Bool,
    filter_constraints::Union{Nothing,Function} = nothing,
)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> by adding the variables and then the constraints and attributes incrementally. The function <a href="../../../reference/models/#MathOptInterface.supports_incremental_interface"><code>MathOptInterface.supports_incremental_interface</code></a> can be used to check whether <code>dest</code> supports the copying a model incrementally.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy.jl#L581-L597">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.IndexMap" href="#MathOptInterface.Utilities.IndexMap"><code>MathOptInterface.Utilities.IndexMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IndexMap(n::Int = 0)</code></pre><p>Dictionary-like object returned by <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> that contains the mapping between variable indices in <code>.var_map</code> and between constraint indices in <code>.con_map</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/index_map.jl#L11-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.identity_index_map" href="#MathOptInterface.Utilities.identity_index_map"><code>MathOptInterface.Utilities.identity_index_map</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">identity_index_map(model::MOI.ModelLike)</code></pre><p>Return an <a href="#MathOptInterface.Utilities.IndexMap"><code>IndexMap</code></a> that maps all variable and constraint indices of <code>model</code> to themselves.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/index_map.jl#L57-L62">source</a></section></article><h3 id="allocate_load_api_ref"><a class="docs-heading-anchor" href="#allocate_load_api_ref">Allocate-Load API</a><a id="allocate_load_api_ref-1"></a><a class="docs-heading-anchor-permalink" href="#allocate_load_api_ref" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_load" href="#MathOptInterface.Utilities.allocate_load"><code>MathOptInterface.Utilities.allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_load(
    dest::MOI.ModelLike,
    src::MOI.ModelLike,
    filter_constraints::Union{Nothing,Function} = nothing,
)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> using the Allocate-Load API. The function <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>supports_allocate_load</code></a> can be used to check whether <code>dest</code> supports the Allocate-Load API.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L346-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_allocate_load" href="#MathOptInterface.Utilities.supports_allocate_load"><code>MathOptInterface.Utilities.supports_allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_allocate_load(model::MOI.ModelLike, copy_names::Bool)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <a href="#MathOptInterface.Utilities.allocate_load"><code>allocate_load(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_variables" href="#MathOptInterface.Utilities.allocate_variables"><code>MathOptInterface.Utilities.allocate_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Creates <code>nvars</code> variables and returns a vector of <code>nvars</code> variable indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L21-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constrained_variable" href="#MathOptInterface.Utilities.allocate_constrained_variable"><code>MathOptInterface.Utilities.allocate_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_constrained_variable(
    model::MOI.ModelLike,
    set::MOI.AbstractScalarSet,
)</code></pre><p>Returns a tuple with the variable index and the index for the constraint to be used in <code>load_allocate_constraint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L28-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constrained_variables" href="#MathOptInterface.Utilities.allocate_constrained_variables"><code>MathOptInterface.Utilities.allocate_constrained_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_constrained_variables(
    model::MOI.ModelLike,
    set::MOI.AbstractVectorSet,
)</code></pre><p>Returns a tuple with the variable indices and the index for the constraint to be used in <code>load_allocate_constraint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L48-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate" href="#MathOptInterface.Utilities.allocate"><code>MathOptInterface.Utilities.allocate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate(
    model::ModelLike,
    attr::ModelLikeAttribute,
    value,
)

allocate(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    v::VariableIndex,
    value,
)

allocate(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::ConstraintIndex,
    value,
)</code></pre><p>Informs <code>model</code> that <code>load</code> will be called with the same arguments after <code>load_variables</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L71-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constraint" href="#MathOptInterface.Utilities.allocate_constraint"><code>MathOptInterface.Utilities.allocate_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_constraint(
    model::MOI.ModelLike,
    f::MOI.AbstractFunction,
    s::MOI.AbstractSet,
)</code></pre><p>Returns the index for the constraint to be used in <code>load_constraint</code> that will be called after <code>load_variables</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L115-L124">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_variables" href="#MathOptInterface.Utilities.load_variables"><code>MathOptInterface.Utilities.load_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Prepares <code>model</code> for <a href="#MathOptInterface.Utilities.load"><code>load</code></a> and <a href="#MathOptInterface.Utilities.load_constraint"><code>load_constraint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constrained_variable" href="#MathOptInterface.Utilities.load_constrained_variable"><code>MathOptInterface.Utilities.load_constrained_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constrained_variable(
    model::MOI.ModelLike, vi::MOI.VariableIndex,
    ci::MOI.ConstraintIndex{MOI.SingleVariable},
    set::MOI.AbstractScalarSet,
)</code></pre><p>Load the constrained variable <code>vi</code> to set <code>set</code> to <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constrained_variables" href="#MathOptInterface.Utilities.load_constrained_variables"><code>MathOptInterface.Utilities.load_constrained_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constrained_variables(
    model::MOI.ModelLike, vi::MOI.VariableIndex,
    ci::MOI.ConstraintIndex{MOI.VectorOfVariables},
    set::MOI.AbstractVectorSet,
)</code></pre><p>Load the constrained variable <code>vi</code> to set <code>set</code> to <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L165-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load" href="#MathOptInterface.Utilities.load"><code>MathOptInterface.Utilities.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(
    model::ModelLike,
    attr::ModelLikeAttribute,
    value,
)

load(
    model::ModelLike,
    attr::AbstractVariableAttribute,
    v::VariableIndex,
    value,
)

load(
    model::ModelLike,
    attr::AbstractConstraintAttribute,
    c::ConstraintIndex,
    value,
)</code></pre><p>This has the same effect that <code>set</code> with the same arguments except that <code>allocate</code> should be called first before <code>load_variables</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L185-L208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constraint" href="#MathOptInterface.Utilities.load_constraint"><code>MathOptInterface.Utilities.load_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constraint(
    model::MOI.ModelLike,
    ci::MOI.ConstraintIndex,
    f::MOI.AbstractFunction,
    s::MOI.AbstractSet,
)</code></pre><p>Sets the constraint function and set for the constraint of index <code>ci</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy/allocate_load.jl#L291-L300">source</a></section></article><h2 id="Utilities.MatrixOfConstraints"><a class="docs-heading-anchor" href="#Utilities.MatrixOfConstraints">Utilities.MatrixOfConstraints</a><a id="Utilities.MatrixOfConstraints-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.MatrixOfConstraints" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MatrixOfConstraints" href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MathOptInterface.Utilities.MatrixOfConstraints</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct MatrixOfConstraints{T,AT,BT,ST} &lt;: MOI.ModelLike
    coefficients::AT
    constants::BT
    sets::ST
    are_indices_mapped::BitSet
    caches::Union{Nothing, Vector}
    function MatrixOfConstraints{T,AT,BT,ST}() where {T,AT,BT,ST}
        return new{T,AT,BT,ST}(AT(), BT(), ST(), BitSet(), nothing)
    end
end</code></pre><p>Represents affine constraints in a matrix form where the linear coefficients of the functions are stored in the <code>coefficients</code> field and the constants of the functions or sets are stored in the <code>sets</code> field. Additional information about the sets are stored in the <code>sets</code> field.</p><p>This model can only be used as the <code>constraints</code> field of a <code>MOI.Utilities.AbstractModel</code>. When the constraints are added, they are stored in the <code>caches</code> field. They are only loaded in the <code>coefficients</code> and <code>constants</code> fields once <code>MOI.Utilities.final_touch</code> is called. For this reason, this should not be used with incremental building of the model but with a <code>MOI.copy_to</code> instead.</p><p>The constraints can be added in two different ways:</p><ol><li>With <code>add_constraint</code> in which case a canonicalized copy of the function is stored in <code>caches</code>.</li><li>With <code>pass_nonvariable_constraints</code> in which case the functions and sets are stored themselves in <code>caches</code> without mapping the variable indices. The corresponding index in <code>caches</code> is added in <code>are_indices_mapped</code>. This allows to avoid doing a copy of the function in case the getter of <code>CanonicalConstraintFunction</code> does not make a copy for the source model, e.g., this is the case of <code>VectorOfConstraints</code>.</li></ol><p>We illustrate this with an example. Suppose a model is copied from a <code>src::MOI.Utilities.Model</code> to a bridged model with a <code>MatrixOfConstraints</code>. For all the types that are not bridged, the constraints will be copied with <code>pass_nonvariable_constraints</code> hence the functions stored in <code>caches</code> are exactly the same as the ones stored in <code>src</code>. This is ok since this is only during the <code>copy_to</code> operation during which <code>src</code> cannot be modified. On the other hand, for the types that are bridged, the functions added may contain duplicates even if the functions did not contain duplicates in <code>src</code> so duplicates are removed with <code>MOI.Utilities.canonical</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/matrix_of_constraints.jl#L78-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.rows" href="#MathOptInterface.Utilities.rows"><code>MathOptInterface.Utilities.rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rows(model::MatrixOfConstraints, ci::MOI.ConstraintIndex)</code></pre><p>Return the rows corresponding to the constraint of index <code>ci</code>. If it is a vector constraint, this is a <code>UnitRange</code>, otherwise, this is an integer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/matrix_of_constraints.jl#L145-L150">source</a></section></article><h3 id="Constants"><a class="docs-heading-anchor" href="#Constants">Constants</a><a id="Constants-1"></a><a class="docs-heading-anchor-permalink" href="#Constants" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Box" href="#MathOptInterface.Utilities.Box"><code>MathOptInterface.Utilities.Box</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Box{T}
    lower::Vector{T}
    upper::Vector{T}
end</code></pre><p>Stores the constants of scalar constraints with the lower bound of the set in <code>lower</code> and the upper bound in <code>upper</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/matrix_of_constraints.jl#L32-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constants" href="#MathOptInterface.Utilities.load_constants"><code>MathOptInterface.Utilities.load_constants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constants(constants, offset, func_or_set)</code></pre><p>This function loads the constants of <code>func_or_set</code> in <code>constants</code> at an offset of <code>offset</code>. Where <code>offset</code> is the sum of the dimensions of the constraints already loaded. The storage should be preallocated with <code>resize!</code> before calling this function.</p><p>This function should be implemented to be usable as storage of constants for <a href="#MathOptInterface.Utilities.MatrixOfConstraints"><code>MatrixOfConstraints</code></a>.</p><p><strong>The constants are loaded in three steps:</strong></p><p><strong>1) <code>Base.empty!</code> is called.</strong></p><p><strong>2) <code>Base.resize!</code> is called with the sum of the dimensions of all constraints.</strong></p><p><strong>3) <code>MOI.Utilities.load_constants</code> is called for each function for vector</strong></p><p><strong>constraint or set for scalar constraint.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/matrix_of_constraints.jl#L4-L20">source</a></section></article><h3 id="Mutable-sparse-matrix"><a class="docs-heading-anchor" href="#Mutable-sparse-matrix">Mutable sparse matrix</a><a id="Mutable-sparse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Mutable-sparse-matrix" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MutableSparseMatrixCSC" href="#MathOptInterface.Utilities.MutableSparseMatrixCSC"><code>MathOptInterface.Utilities.MutableSparseMatrixCSC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">mutable struct MutableSparseMatrixCSC{Tv,Ti&lt;:Integer,I&lt;:AbstractIndexing}
    indexing::I
    m::Int
    n::Int
    colptr::Vector{Ti}
    rowval::Vector{Ti}
    nzval::Vector{Tv}
end</code></pre><p>Matrix type loading sparse matrices in the Compressed Sparse Column format. The indexing used is <code>indexing</code>, see <a href="#MathOptInterface.Utilities.AbstractIndexing"><code>AbstractIndexing</code></a>. The other fields have the same meaning than for <code>SparseArrays.SparseMatrixCSC</code> except that the indexing is different unless <code>indexing</code> is <code>OneBasedIndexing</code>.</p><p>The matrix is loaded in 5 steps:</p><ol><li><code>MOI.empty!</code> is called.</li><li><code>MOI.Utilities.add_column</code> and <code>MOI.Utilities.allocate_terms</code> are called in any order.</li><li><code>MOI.Utilities.set_number_of_rows</code> is called.</li><li><code>MOI.Utilities.load_terms</code> is called for each affine function.</li><li><code>MOI.Utilities.final_touch</code> is called.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L38-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.AbstractIndexing" href="#MathOptInterface.Utilities.AbstractIndexing"><code>MathOptInterface.Utilities.AbstractIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractIndexing end</code></pre><p>Indexing to be used for storing the row and column indices of <code>MutableSparseMatrixCSC</code>. See <a href="#MathOptInterface.Utilities.ZeroBasedIndexing"><code>ZeroBasedIndexing</code></a> and <a href="#MathOptInterface.Utilities.OneBasedIndexing"><code>OneBasedIndexing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ZeroBasedIndexing" href="#MathOptInterface.Utilities.ZeroBasedIndexing"><code>MathOptInterface.Utilities.ZeroBasedIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ZeroBasedIndexing &lt;: AbstractIndexing end</code></pre><p>Zero-based indexing: the <code>i</code>th row or column has index <code>i - 1</code>. This is useful when the vectors of row and column indices need to be communicated to a library using zero-based indexing such as C libraries.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L12-L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.OneBasedIndexing" href="#MathOptInterface.Utilities.OneBasedIndexing"><code>MathOptInterface.Utilities.OneBasedIndexing</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ZeroBasedIndexing &lt;: AbstractIndexing end</code></pre><p>One-based indexing: the <code>i</code>th row or column has index <code>i</code>. This enables an allocation-free conversion of <a href="#MathOptInterface.Utilities.MutableSparseMatrixCSC"><code>MutableSparseMatrixCSC</code></a> to <code>SparseArrays.SparseMatrixCSC</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L21-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.add_column" href="#MathOptInterface.Utilities.add_column"><code>MathOptInterface.Utilities.add_column</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_column(A::MutableSparseMatrixCSC)</code></pre><p>Add a column to the matrix <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_terms" href="#MathOptInterface.Utilities.allocate_terms"><code>MathOptInterface.Utilities.allocate_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_terms(A::MutableSparseMatrixCSC, index_map, func)</code></pre><p>Informs <code>A</code> that the terms of the function <code>func</code> where the variable indices are mapped with <code>index_map</code> will be loaded with <a href="#MathOptInterface.Utilities.load_terms"><code>load_terms</code></a>. The function <code>func</code> should be canonicalized, see <a href="#MathOptInterface.Utilities.is_canonical"><code>is_canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L130-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_number_of_rows" href="#MathOptInterface.Utilities.set_number_of_rows"><code>MathOptInterface.Utilities.set_number_of_rows</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_number_of_rows(coefficients, n)</code></pre><p>This function sets the number of rows to <code>coefficients</code>. This allows it to preallocate necessary datastructures before the data is loaded with <a href="#MathOptInterface.Utilities.load_terms"><code>load_terms</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_terms" href="#MathOptInterface.Utilities.load_terms"><code>MathOptInterface.Utilities.load_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_terms(A::MutableSparseMatrixCSC, index_map, func, offset)</code></pre><p>Loads the terms of <code>func</code> to <code>A</code> mapping the variable indices with <code>index_map</code>. The <code>i</code>th dimension of <code>func</code> is loaded at the <code>(offset + i)</code>th row of <code>A</code>. The function should be allocated first with <a href="#MathOptInterface.Utilities.allocate_terms"><code>allocate_terms</code></a>. The function <code>func</code> should be canonicalized, see <a href="#MathOptInterface.Utilities.is_canonical"><code>is_canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L153-L160">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.final_touch" href="#MathOptInterface.Utilities.final_touch"><code>MathOptInterface.Utilities.final_touch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">function final_touch(model::MOI.ModelLike, idxmap) end</code></pre><p>This is called at the end of <a href="#MathOptInterface.Utilities.default_copy_to"><code>default_copy_to</code></a> to inform the model that the copy is finished. This allows <code>model</code> to perform thats that should be done only once all the model information is gathered.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/copy.jl#L572-L578">source</a></section><section><div><pre><code class="language-none">final_touch(A::MutableSparseMatrixCSC)</code></pre><p>Informs the matrix <code>A</code> that all functions have been added with <code>load_terms</code>. No more modification is allowed unless <code>MOI.empty!</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sparse_matrix.jl#L109-L114">source</a></section></article><h3 id="Product-of-sets"><a class="docs-heading-anchor" href="#Product-of-sets">Product of sets</a><a id="Product-of-sets-1"></a><a class="docs-heading-anchor-permalink" href="#Product-of-sets" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.ProductOfSets" href="#MathOptInterface.Utilities.ProductOfSets"><code>MathOptInterface.Utilities.ProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type ProductOfSets{T} end</code></pre><p>Represents a cartesian product of sets of given types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_index" href="#MathOptInterface.Utilities.set_index"><code>MathOptInterface.Utilities.set_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_index(sets::ProductOfSets, ::Type{S}) where {S&lt;:MOI.AbstractSet}</code></pre><p>Return an integer corresponding to the index of the set type in the list given by <a href="#MathOptInterface.Utilities.set_types"><code>set_types</code></a>. If this set is not part of the list then it returns <code>nothing</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L8-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.set_types" href="#MathOptInterface.Utilities.set_types"><code>MathOptInterface.Utilities.set_types</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">set_types(sets::ProductOfSets)</code></pre><p>Return the list of the types of the sets allowed in the cartesian product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.add_set" href="#MathOptInterface.Utilities.add_set"><code>MathOptInterface.Utilities.add_set</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">add_set(sets::OrderedProductOfSets, i)</code></pre><p>Add a scalar set of type index <code>i</code>.</p><pre><code class="language-none">add_set(sets::OrderedProductOfSets, i, dim)</code></pre><p>Add a vector set of type index <code>i</code> and dimension <code>dim</code>.</p><p>Both method return a unique id of the set that can be used to reference this set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L24-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.indices" href="#MathOptInterface.Utilities.indices"><code>MathOptInterface.Utilities.indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">indices(sets::OrderedProductOfSets, ci::MOI.ConstraintIndex)</code></pre><p>Return the indices in <code>1:MOI.dimension(sets)</code> corresponding to the set of id <code>ci.value</code>. For scalar sets, this return an integer and for vector sets, this return an <code>UnitRange</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L38-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.MixOfScalarSets" href="#MathOptInterface.Utilities.MixOfScalarSets"><code>MathOptInterface.Utilities.MixOfScalarSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type MixOfScalarSets{T} &lt;: ProductOfSets{T} end</code></pre><p>Product of scalar sets in the order the constraints are added, mixing the constraints of different types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.OrderedProductOfSets" href="#MathOptInterface.Utilities.OrderedProductOfSets"><code>MathOptInterface.Utilities.OrderedProductOfSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type OrderedProductOfSets{T} &lt;: ProductOfSets{T} end</code></pre><p>Product of sets in the order the constraints are added, grouping the constraints of the same types contiguously.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L136-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.OrderedProductOfScalarSets" href="#MathOptInterface.Utilities.OrderedProductOfScalarSets"><code>MathOptInterface.Utilities.OrderedProductOfScalarSets</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type OrderedProductOfScalarSets{T} &lt;: OrderedProductOfSets{T} end</code></pre><p>Same as <a href="#MathOptInterface.Utilities.OrderedProductOfSets"><code>OrderedProductOfSets</code></a> except that all types are scalar sets, which allows a more efficient implementation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/product_of_sets.jl#L158-L163">source</a></section></article><h2 id="Fallbacks"><a class="docs-heading-anchor" href="#Fallbacks">Fallbacks</a><a id="Fallbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Fallbacks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_fallback" href="#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)</code></pre><p>Compute the objective function value using the <code>VariablePrimal</code> results and the <code>ObjectiveFunction</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/results.jl#L13-L18">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T</code></pre><p>Compute the dual objective value of type <code>T</code> using the <code>ConstraintDual</code> results and the <code>ConstraintFunction</code> and <code>ConstraintSet</code> values. Note that the nonlinear part of the model is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/results.jl#L135-L141">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,
             constraint_index::MOI.ConstraintIndex)</code></pre><p>Compute the value of the function of the constraint of index <code>constraint_index</code> using the <code>VariablePrimal</code> results and the <code>ConstraintFunction</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/results.jl#L163-L169">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,
             ci::MOI.ConstraintIndex{Union{MOI.SingleVariable,
                                           MOI.VectorOfVariables}})</code></pre><p>Compute the dual of the constraint of index <code>ci</code> using the <code>ConstraintDual</code> of other constraints and the <code>ConstraintFunction</code> values. Throws an error if some constraints are quadratic or if there is one another <code>MOI.SingleVariable</code>-in-<code>S</code> or <code>MOI.VectorOfVariables</code>-in-<code>S</code> constraint with one of the variables in the function of the constraint <code>ci</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/results.jl#L473-L483">source</a></section></article><h2 id="Function-utilities"><a class="docs-heading-anchor" href="#Function-utilities">Function utilities</a><a id="Function-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Function-utilities" title="Permalink"></a></h2><p>The following utilities are available for functions:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.eval_variables" href="#MathOptInterface.Utilities.eval_variables"><code>MathOptInterface.Utilities.eval_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_variables(varval::Function, f::AbstractFunction)</code></pre><p>Returns the value of function <code>f</code> if each variable index <code>vi</code> is evaluated as <code>varval(vi)</code>. Note that <code>varval</code> should return a number, see <a href="#MathOptInterface.Utilities.substitute_variables"><code>substitute_variables</code></a> for a similar function where <code>varval</code> returns a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.map_indices" href="#MathOptInterface.Utilities.map_indices"><code>MathOptInterface.Utilities.map_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_indices(index_map::Function, x)</code></pre><p>Substitute any <a href="../../../reference/variables/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/constraints/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) in <code>x</code> by the <a href="../../../reference/variables/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/constraints/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) of the same type given by <code>index_map(x)</code>.</p><p>This function is used by implementations of <a href="../../../reference/models/#MathOptInterface.copy_to"><code>MOI.copy_to</code></a> on constraint functions, attribute values and submittable values hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L65-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.substitute_variables" href="#MathOptInterface.Utilities.substitute_variables"><code>MathOptInterface.Utilities.substitute_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">substitute_variables(variable_map::Function, x)</code></pre><p>Substitute any <a href="../../../reference/variables/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>x</code> by <code>variable_map(x)</code>. The <code>variable_map</code> function returns either <a href="../../../reference/standard_form/#MathOptInterface.SingleVariable"><code>MOI.SingleVariable</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, see <a href="#MathOptInterface.Utilities.eval_variables"><code>eval_variables</code></a> for a similar function where <code>variable_map</code> returns a number.</p><p>This function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p><p>WARNING: Don&#39;t use <code>substitude_variables(::Function, ...)</code> because Julia will not specialize on this. Use instead <code>substitude_variables(::F, ...) where {F&lt;:Function}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L208-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.filter_variables" href="#MathOptInterface.Utilities.filter_variables"><code>MathOptInterface.Utilities.filter_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter_variables(keep::Function, f::AbstractFunction)</code></pre><p>Return a new function <code>f</code> with the variable <code>vi</code> such that <code>!keep(vi)</code> removed.</p><p>WARNING: Don&#39;t define <code>filter_variables(::Function, ...)</code> because Julia will not specialize on this. Define instead <code>filter_variables(::F, ...) where {F&lt;:Function}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L996-L1004">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.remove_variable" href="#MathOptInterface.Utilities.remove_variable"><code>MathOptInterface.Utilities.remove_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_variable(f::AbstractFunction, vi::VariableIndex)</code></pre><p>Return a new function <code>f</code> with the variable vi removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1039-L1043">source</a></section><section><div><pre><code class="language-none">remove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(g, t)</code> representing the constraint <code>f</code>-in-<code>s</code> with the variable <code>vi</code> removed. That is, the terms containing the variable <code>vi</code> in the function <code>f</code> are removed and the dimension of the set <code>s</code> is updated if needed (e.g. when <code>f</code> is a <code>VectorOfVariables</code> with <code>vi</code> being one of the variables).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/model.jl#L49-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.all_coefficients" href="#MathOptInterface.Utilities.all_coefficients"><code>MathOptInterface.Utilities.all_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_coefficients(p::Function, f::MOI.AbstractFunction)</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all coefficients of <code>f</code>, returning <code>false</code> as soon as the first coefficient of <code>f</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting). Similar to <code>all</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L836-L842">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.unsafe_add" href="#MathOptInterface.Utilities.unsafe_add"><code>MathOptInterface.Utilities.unsafe_add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarAffineTerm</code>. It is unsafe because it uses the <code>variable</code> of <code>t1</code> as the <code>variable</code> of the output without checking that it is equal to that of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L589-L593">source</a></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarQuadraticTerm</code>. It is unsafe because it uses the <code>variable</code>&#39;s of <code>t1</code> as the <code>variable</code>&#39;s of the output without checking that they are the same (up to permutation) to those of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L598-L605">source</a></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.VectorAffineTerm</code>. It is unsafe because it uses the <code>output_index</code> and <code>variable</code> of <code>t1</code> as the <code>output_index</code> and <code>variable</code> of the output term without checking that they are equal to those of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.isapprox_zero" href="#MathOptInterface.Utilities.isapprox_zero"><code>MathOptInterface.Utilities.isapprox_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapprox_zero(f::MOI.AbstractFunction, tol)</code></pre><p>Return a <code>Bool</code> indicating whether the function <code>f</code> is approximately zero using <code>tol</code> as a tolerance.</p><p><strong>Important note</strong></p><p>This function assumes that <code>f</code> does not contain any duplicate terms, you might want to first call <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a> if that is not guaranteed. For instance, given</p><pre><code class="language-julia">f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)`.</code></pre><p>then <code>isapprox_zero(f)</code> is <code>false</code> but <code>isapprox_zero(MOIU.canonical(f))</code> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L855-L871">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.modify_function" href="#MathOptInterface.Utilities.modify_function"><code>MathOptInterface.Utilities.modify_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modify_function(f::AbstractFunction, change::AbstractFunctionModification)</code></pre><p>Return a new function <code>f</code> modified according to <code>change</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1056-L1060">source</a></section></article><p>The following functions can be used to canonicalize a function:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_canonical" href="#MathOptInterface.Utilities.is_canonical"><code>MathOptInterface.Utilities.is_canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L629-L634">source</a></section><section><div><pre><code class="language-none">is_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L643-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonical" href="#MathOptInterface.Utilities.canonical"><code>MathOptInterface.Utilities.canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical(f::Union{ScalarAffineFunction, VectorAffineFunction,
                   ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns the function in a canonical form, i.e.</p><ul><li>A term appear only once.</li><li>The coefficients are nonzero.</li><li>The terms appear in increasing order of variable where there the order of the variables is the order of their value.</li><li>For a <code>AbstractVectorFunction</code>, the terms are sorted in ascending order of output index.</li></ul><p>The output of <code>canonical</code> can be assumed to be a copy of <code>f</code>, even for <code>VectorOfVariables</code>.</p><p><strong>Examples</strong></p><p>If <code>x</code> (resp. <code>y</code>, <code>z</code>) is <code>VariableIndex(1)</code> (resp. 2, 3). The canonical representation of <code>ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5)</code> is <code>ScalarAffineFunction([x, y], [-1, 2], 5)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L691-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonicalize!" href="#MathOptInterface.Utilities.canonicalize!"><code>MathOptInterface.Utilities.canonicalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L712-L717">source</a></section><section><div><pre><code class="language-none">canonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L728-L733">source</a></section></article><p>The following functions can be used to manipulate functions with basic algebra:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.scalar_type" href="#MathOptInterface.Utilities.scalar_type"><code>MathOptInterface.Utilities.scalar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scalar_type(F::Type{&lt;:MOI.AbstractVectorFunction})</code></pre><p>Type of functions obtained by indexing objects obtained by calling <code>eachscalar</code> on functions of type <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L370-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.promote_operation" href="#MathOptInterface.Utilities.promote_operation"><code>MathOptInterface.Utilities.promote_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_operation(op::Function, ::Type{T},
                  ArgsTypes::Type{&lt;:Union{T, MOI.AbstractFunction}}...) where T</code></pre><p>Returns the type of the <code>MOI.AbstractFunction</code> returned to the call <code>operate(op, T, args...)</code> where the types of the arguments <code>args</code> are <code>ArgsTypes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1244-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate" href="#MathOptInterface.Utilities.operate"><code>MathOptInterface.Utilities.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate(op::Function, ::Type{T},
        args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. No argument can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1182-L1189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate!" href="#MathOptInterface.Utilities.operate!"><code>MathOptInterface.Utilities.operate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate!(op::Function, ::Type{T},
         args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. The first argument can be modified. The return type is the same than the method <code>operate(op, T, args...)</code> without <code>!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1201-L1209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate_output_index!" href="#MathOptInterface.Utilities.operate_output_index!"><code>MathOptInterface.Utilities.operate_output_index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate_output_index!(
    op::Function, ::Type{T}, output_index::Integer,
    func::MOI.AbstractVectorFunction
    args::Union{T, MOI.AbstractScalarFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractVectorFunction</code> where the function at <code>output_index</code> is the result of the operation <code>op</code> applied to the function at <code>output_index</code> of <code>func</code> and <code>args</code>. The functions at output index different to <code>output_index</code> are the same as the functions at the same output index in <code>func</code>. The first argument can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L1220-L1231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.vectorize" href="#MathOptInterface.Utilities.vectorize"><code>MathOptInterface.Utilities.vectorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vectorize(funcs::AbstractVector{MOI.SingleVariable})</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L2728-L2733">source</a></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L2739-L2744">source</a></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T</code></pre><p>Returns the vector of scalar quadratic functions in the form of a <code>MOI.VectorQuadraticFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/functions.jl#L2756-L2761">source</a></section></article><h2 id="Constraint-utilities"><a class="docs-heading-anchor" href="#Constraint-utilities">Constraint utilities</a><a id="Constraint-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-utilities" title="Permalink"></a></h2><p>The following utilities are available for moving the function constant to the set for scalar constraints:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.shift_constant" href="#MathOptInterface.Utilities.shift_constant"><code>MathOptInterface.Utilities.shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shift_constant(set::MOI.AbstractScalarSet, offset)</code></pre><p>Returns a new scalar set <code>new_set</code> such that <code>func</code>-in-<code>set</code> is equivalent to <code>func + offset</code>-in-<code>new_set</code>.</p><p>Only define this function if it makes sense to!</p><p>Use <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a> to check if the set supports shifting:</p><pre><code class="language-Julia">if supports_shift_constant(typeof(old_set))
    new_set = shift_constant(old_set, offset)
    f.constant = 0
    add_constraint(model, f, new_set)
else
    add_constraint(model, f, old_set)
end</code></pre><p>See also <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a>.</p><p><strong>Examples</strong></p><p>The call <code>shift_constant(MOI.Interval(-2, 3), 1)</code> is equal to <code>MOI.Interval(-1, 4)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sets.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_shift_constant" href="#MathOptInterface.Utilities.supports_shift_constant"><code>MathOptInterface.Utilities.supports_shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_shift_constant(::Type{S}) where {S&lt;:MOI.AbstractSet}</code></pre><p>Return <code>true</code> if <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a> is defined for set <code>S</code>.</p><p>See also <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sets.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_and_add_constraint" href="#MathOptInterface.Utilities.normalize_and_add_constraint"><code>MathOptInterface.Utilities.normalize_and_add_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_and_add_constraint(model::MOI.ModelLike,
                             func::MOI.AbstractScalarFunction,
                             set::MOI.AbstractScalarSet;
                             allow_modify_function::Bool=false)</code></pre><p>Adds the scalar constraint obtained by moving the constant term in <code>func</code> to the set in <code>model</code>. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/constraints.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_constant" href="#MathOptInterface.Utilities.normalize_constant"><code>MathOptInterface.Utilities.normalize_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_constant(func::MOI.AbstractScalarFunction,
                   set::MOI.AbstractScalarSet;
                   allow_modify_function::Bool=false)</code></pre><p>Return the <code>func</code>-in-<code>set</code> constraint in normalized form. That is, if <code>func</code> is <a href="../../../reference/standard_form/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> or <a href="../../../reference/standard_form/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, the constant is moved to the set. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/constraints.jl#L29-L39">source</a></section></article><p>The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_bounds" href="#MathOptInterface.Utilities.get_bounds"><code>MathOptInterface.Utilities.get_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(lb, ub)</code> of type <code>Tuple{T, T}</code>, where <code>lb</code> and <code>ub</code> are lower  and upper bounds, respectively, imposed on <code>x</code> in <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/variables.jl#L1-L6">source</a></section></article><p>The following utilities are useful when working with symmetric matrix cones.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_diagonal_vectorized_index" href="#MathOptInterface.Utilities.is_diagonal_vectorized_index"><code>MathOptInterface.Utilities.is_diagonal_vectorized_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_diagonal_vectorized_index(index::Base.Integer)</code></pre><p>Return whether <code>index</code> is the index of a diagonal element in a <a href="../../../reference/standard_form/#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>MOI.AbstractSymmetricMatrixSetTriangle</code></a> set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sets.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.side_dimension_for_vectorized_dimension" href="#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension"><code>MathOptInterface.Utilities.side_dimension_for_vectorized_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">side_dimension_for_vectorized_dimension(n::Integer)</code></pre><p>Return the dimension <code>d</code> such that <code>MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d))</code> is <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/b51f8bbcbd9a871fe703293d2a845b527ea5395f/src/Utilities/sets.jl#L77-L82">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../../Test/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 20 May 2021 22:23">Thursday 20 May 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
