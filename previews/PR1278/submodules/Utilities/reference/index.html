<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Reference · MathOptInterface</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">MathOptInterface</span></div><form class="docs-search" action="../../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../../">Introduction</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Manual</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../../manual/basic_usage/">Basic usage</a></li><li><a class="tocitem" href="../../../manual/advanced_usage/">Advanced usage</a></li><li><a class="tocitem" href="../../../manual/implementing/">Implementing a solver interface</a></li></ul></li><li><a class="tocitem" href="../../../reference/reference/">API Reference</a></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">Submodules</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><input class="collapse-toggle" id="menuitem-4-1" type="checkbox"/><label class="tocitem" for="menuitem-4-1"><span class="docs-label">Benchmarks</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Benchmarks/overview/">Overview</a></li><li><a class="tocitem" href="../../Benchmarks/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Bridges</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Bridges/overview/">Overview</a></li><li><a class="tocitem" href="../../Bridges/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">FileFormats</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../FileFormats/overview/">Overview</a></li><li><a class="tocitem" href="../../FileFormats/reference/">API Reference</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Utilities</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../overview/">Overview</a></li><li class="is-active"><a class="tocitem" href>API Reference</a><ul class="internal"><li><a class="tocitem" href="#Utilities.Model"><span>Utilities.Model</span></a></li><li><a class="tocitem" href="#Utilities.UniversalFallback"><span>Utilities.UniversalFallback</span></a></li><li><a class="tocitem" href="#Utilities.@macro"><span>Utilities.@macro</span></a></li><li><a class="tocitem" href="#Copy-utilities"><span>Copy utilities</span></a></li><li><a class="tocitem" href="#Fallbacks"><span>Fallbacks</span></a></li><li><a class="tocitem" href="#Function-utilities"><span>Function utilities</span></a></li><li><a class="tocitem" href="#Constraint-utilities"><span>Constraint utilities</span></a></li></ul></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Test</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../Test/overview/">Overview</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Submodules</a></li><li><a class="is-disabled">Utilities</a></li><li class="is-active"><a href>API Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jump-dev/MathOptInterface.jl/blob/master/docs/src/submodules/Utilities/reference.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Utilities.Model"><a class="docs-heading-anchor" href="#Utilities.Model">Utilities.Model</a><a id="Utilities.Model-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.Model" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.Model" href="#MathOptInterface.Utilities.Model"><code>MathOptInterface.Utilities.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <code>ModelLike</code> that supports all functions and sets defined in MOI. It is parameterized by the coefficient type.</p><p><strong>Examples</strong></p><pre><code class="language-jl">model = Model{Float64}()
x = add_variable(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/model.jl#L1425-L1435">source</a></section></article><h2 id="Utilities.UniversalFallback"><a class="docs-heading-anchor" href="#Utilities.UniversalFallback">Utilities.UniversalFallback</a><a id="Utilities.UniversalFallback-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.UniversalFallback" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.UniversalFallback" href="#MathOptInterface.Utilities.UniversalFallback"><code>MathOptInterface.Utilities.UniversalFallback</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">UniversalFallback</code></pre><p>The <code>UniversalFallback</code> can be applied on a <a href="../../../reference/reference/#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a> <code>model</code> to create the model <code>UniversalFallback(model)</code> supporting <em>any</em> constraint and attribute. This allows to have a specialized implementation in <code>model</code> for performance critical constraints and attributes while still supporting other attributes with a small performance penalty. Note that <code>model</code> is unaware of constraints and attributes stored by <code>UniversalFallback</code> so this is not appropriate if <code>model</code> is an optimizer (for this reason, <a href="../../../reference/reference/#MathOptInterface.optimize!"><code>MathOptInterface.optimize!</code></a> has not been implemented). In that case, optimizer bridges should be used instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/universalfallback.jl#L1-L13">source</a></section></article><h2 id="Utilities.@macro"><a class="docs-heading-anchor" href="#Utilities.@macro">Utilities.@macro</a><a id="Utilities.@macro-1"></a><a class="docs-heading-anchor-permalink" href="#Utilities.@macro" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.@model" href="#MathOptInterface.Utilities.@model"><code>MathOptInterface.Utilities.@model</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">macro model(
    model_name,
    scalar_sets,
    typed_scalar_sets,
    vector_sets,
    typed_vector_sets,
    scalar_functions,
    typed_scalar_functions,
    vector_functions,
    typed_vector_functions,
    is_optimizer = false
)</code></pre><p>Creates a type <code>model_name</code> implementing the MOI model interface and containing <code>scalar_sets</code> scalar sets <code>typed_scalar_sets</code> typed scalar sets, <code>vector_sets</code> vector sets, <code>typed_vector_sets</code> typed vector sets, <code>scalar_functions</code> scalar functions, <code>typed_scalar_functions</code> typed scalar functions, <code>vector_functions</code> vector functions and <code>typed_vector_functions</code> typed vector functions. To give no set/function, write <code>()</code>, to give one set <code>S</code>, write <code>(S,)</code>.</p><p>The function <a href="../../../reference/reference/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> should not be given in <code>scalar_functions</code>. The model supports <a href="../../../reference/reference/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a>-in-<code>F</code> constraints where <code>F</code> is <a href="../../../reference/reference/#MathOptInterface.EqualTo"><code>MathOptInterface.EqualTo</code></a>, <a href="../../../reference/reference/#MathOptInterface.GreaterThan"><code>MathOptInterface.GreaterThan</code></a>, <a href="../../../reference/reference/#MathOptInterface.LessThan"><code>MathOptInterface.LessThan</code></a>, <a href="../../../reference/reference/#MathOptInterface.Interval"><code>MathOptInterface.Interval</code></a>, <a href="../../../reference/reference/#MathOptInterface.Integer"><code>MathOptInterface.Integer</code></a>, <a href="../../../reference/reference/#MathOptInterface.ZeroOne"><code>MathOptInterface.ZeroOne</code></a>, <a href="../../../reference/reference/#MathOptInterface.Semicontinuous"><code>MathOptInterface.Semicontinuous</code></a> or <a href="../../../reference/reference/#MathOptInterface.Semiinteger"><code>MathOptInterface.Semiinteger</code></a>. The sets supported with the <a href="../../../reference/reference/#MathOptInterface.SingleVariable"><code>MathOptInterface.SingleVariable</code></a> cannot be controlled from the macro, use the <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a> to support more sets.</p><p>This macro creates a model specialized for specific types of constraint, by defining specialized structures and methods. To create a model that, in addition to be optimized for specific constraints, also support arbitrary constraints and attributes, use <a href="#MathOptInterface.Utilities.UniversalFallback"><code>UniversalFallback</code></a>.</p><p>This implementation of the MOI model certifies that the constraint indices, in addition to being different between constraints <code>F</code>-in-<code>S</code> for the same types <code>F</code> and <code>S</code>, are also different between constraints for different types <code>F</code> and <code>S</code>. This means that for constraint indices <code>ci1</code>, <code>ci2</code> of this model, <code>ci1 == ci2</code> if and only if <code>ci1.value == ci2.value</code>. This fact can be used to use the the value of the index directly in a dictionary representing a mapping between constraint indices and something else.</p><p>If <code>is_optimizer = true</code>, the resulting struct is a subtype of of <code>MOIU.AbstractOptimizer</code>, which is a subtype of <a href="../../../reference/reference/#MathOptInterface.AbstractOptimizer"><code>MathOptInterface.AbstractOptimizer</code></a>, otherwise, it is a subtype of <code>MOIU.AbstractModelLike</code>, which is a subtype of <a href="../../../reference/reference/#MathOptInterface.ModelLike"><code>MathOptInterface.ModelLike</code></a>.</p><p><strong>Examples</strong></p><p>The model describing an linear program would be:</p><pre><code class="language-julia">@model(LPModel,                                                   # Name of model
      (),                                                         # untyped scalar sets
      (MOI.EqualTo, MOI.GreaterThan, MOI.LessThan, MOI.Interval), #   typed scalar sets
      (MOI.Zeros, MOI.Nonnegatives, MOI.Nonpositives),            # untyped vector sets
      (),                                                         #   typed vector sets
      (),                                                         # untyped scalar functions
      (MOI.ScalarAffineFunction,),                                #   typed scalar functions
      (MOI.VectorOfVariables,),                                   # untyped vector functions
      (MOI.VectorAffineFunction,),                                #   typed vector functions
      false
    )</code></pre><p>Let <code>MOI</code> denote <code>MathOptInterface</code>, <code>MOIU</code> denote <code>MOI.Utilities</code> and <code>MOIU.ConstraintEntry{F, S}</code> be defined as <code>MOI.Tuple{MOI.ConstraintIndex{F, S}, F, S}</code>. The macro would create the types:</p><pre><code class="language-julia">struct LPModelScalarConstraints{T, F &lt;: MOI.AbstractScalarFunction} &lt;: MOIU.Constraints{F}
    equalto::Vector{MOIU.ConstraintEntry{F, MOI.EqualTo{T}}}
    greaterthan::Vector{MOIU.ConstraintEntry{F, MOI.GreaterThan{T}}}
    lessthan::Vector{MOIU.ConstraintEntry{F, MOI.LessThan{T}}}
    interval::Vector{MOIU.ConstraintEntry{F, MOI.Interval{T}}}
end
struct LPModelVectorConstraints{T, F &lt;: MOI.AbstractVectorFunction} &lt;: MOIU.Constraints{F}
    zeros::Vector{MOIU.ConstraintEntry{F, MOI.Zeros}}
    nonnegatives::Vector{MOIU.ConstraintEntry{F, MOI.Nonnegatives}}
    nonpositives::Vector{MOIU.ConstraintEntry{F, MOI.Nonpositives}}
end
mutable struct LPModel{T} &lt;: MOIU.AbstractModel{T}
    name::String
    sense::MOI.OptimizationSense
    objective::Union{MOI.SingleVariable, MOI.ScalarAffineFunction{T}, MOI.ScalarQuadraticFunction{T}}
    num_variables_created::Int64
    # If nothing, no variable has been deleted so the indices of the
    # variables are VI.(1:num_variables_created)
    variable_indices::Union{Nothing, Set{MOI.VariableIndex}}
    # Union of flags of `S` such that a `SingleVariable`-in-`S`
    # constraint was added to the model and not deleted yet.
    single_variable_mask::Vector{UInt8}
    # Lower bound set by `SingleVariable`-in-`S` where `S`is
    # `GreaterThan{T}`, `EqualTo{T}` or `Interval{T}`.
    lower_bound::Vector{T}
    # Lower bound set by `SingleVariable`-in-`S` where `S`is
    # `LessThan{T}`, `EqualTo{T}` or `Interval{T}`.
    upper_bound::Vector{T}
    var_to_name::Dict{MOI.VariableIndex, String}
    # If `nothing`, the dictionary hasn&#39;t been constructed yet.
    name_to_var::Union{Dict{String, MOI.VariableIndex}, Nothing}
    nextconstraintid::Int64
    con_to_name::Dict{MOI.ConstraintIndex, String}
    name_to_con::Union{Dict{String, MOI.ConstraintIndex}, Nothing}
    constrmap::Vector{Int}
    scalaraffinefunction::LPModelScalarConstraints{T, MOI.ScalarAffineFunction{T}}
    vectorofvariables::LPModelVectorConstraints{T, MOI.VectorOfVariables}
    vectoraffinefunction::LPModelVectorConstraints{T, MOI.VectorAffineFunction{T}}
end</code></pre><p>The type <code>LPModel</code> implements the MathOptInterface API except methods specific to solver models like <code>optimize!</code> or <code>getattribute</code> with <code>VariablePrimal</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/model.jl#L1028-L1141">source</a></section></article><h3 id="Caching-optimizer"><a class="docs-heading-anchor" href="#Caching-optimizer">Caching optimizer</a><a id="Caching-optimizer-1"></a><a class="docs-heading-anchor-permalink" href="#Caching-optimizer" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.CachingOptimizer" href="#MathOptInterface.Utilities.CachingOptimizer"><code>MathOptInterface.Utilities.CachingOptimizer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CachingOptimizer</code></pre><p><code>CachingOptimizer</code> is an intermediate layer that stores a cache of the model and links it with an optimizer. It supports incremental model construction and modification even when the optimizer doesn&#39;t.</p><p>A <code>CachingOptimizer</code> may be in one of three possible states (<code>CachingOptimizerState</code>):</p><ul><li><code>NO_OPTIMIZER</code>: The CachingOptimizer does not have any optimizer.</li><li><code>EMPTY_OPTIMIZER</code>: The CachingOptimizer has an empty optimizer. The optimizer is not synchronized with the cached model.</li><li><code>ATTACHED_OPTIMIZER</code>: The CachingOptimizer has an optimizer, and it is synchronized with the cached model.</li></ul><p>A <code>CachingOptimizer</code> has two modes of operation (<code>CachingOptimizerMode</code>):</p><ul><li><code>MANUAL</code>: The only methods that change the state of the <code>CachingOptimizer</code> are <a href="#MathOptInterface.Utilities.reset_optimizer"><code>Utilities.reset_optimizer</code></a>, <a href="#MathOptInterface.Utilities.drop_optimizer"><code>Utilities.drop_optimizer</code></a>, and <a href="#MathOptInterface.Utilities.attach_optimizer"><code>Utilities.attach_optimizer</code></a>. Attempting to perform an operation in the incorrect state results in an error.</li><li><code>AUTOMATIC</code>: The <code>CachingOptimizer</code> changes its state when necessary. For example, <code>optimize!</code> will automatically call <code>attach_optimizer</code> (an optimizer must have been previously set). Attempting to add a constraint or perform a modification not supported by the optimizer results in a drop to <code>EMPTY_OPTIMIZER</code> mode.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L6-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.attach_optimizer" href="#MathOptInterface.Utilities.attach_optimizer"><code>MathOptInterface.Utilities.attach_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">attach_optimizer(model::CachingOptimizer)</code></pre><p>Attaches the optimizer to <code>model</code>, copying all model data into it. Can be called only from the <code>EMPTY_OPTIMIZER</code> state. If the copy succeeds, the <code>CachingOptimizer</code> will be in state <code>ATTACHED_OPTIMIZER</code> after the call, otherwise an error is thrown; see <a href="../../../reference/reference/#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> for more details on which errors can be thrown.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L158-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.reset_optimizer" href="#MathOptInterface.Utilities.reset_optimizer"><code>MathOptInterface.Utilities.reset_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">reset_optimizer(m::CachingOptimizer, optimizer::MOI.AbstractOptimizer)</code></pre><p>Sets or resets <code>m</code> to have the given empty optimizer. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L113-L118">source</a></section><section><div><pre><code class="language-none">reset_optimizer(m::CachingOptimizer)</code></pre><p>Detaches and empties the current optimizer. Can be called from <code>ATTACHED_OPTIMIZER</code> or <code>EMPTY_OPTIMIZER</code> state. The <code>CachingOptimizer</code> will be in state <code>EMPTY_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L131-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.drop_optimizer" href="#MathOptInterface.Utilities.drop_optimizer"><code>MathOptInterface.Utilities.drop_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drop_optimizer(m::CachingOptimizer)</code></pre><p>Drops the optimizer, if one is present. Can be called from any state. The <code>CachingOptimizer</code> will be in state <code>NO_OPTIMIZER</code> after the call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L146-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.state" href="#MathOptInterface.Utilities.state"><code>MathOptInterface.Utilities.state</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">state(m::CachingOptimizer)::CachingOptimizerState</code></pre><p>Returns the state of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.mode" href="#MathOptInterface.Utilities.mode"><code>MathOptInterface.Utilities.mode</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mode(m::CachingOptimizer)::CachingOptimizerMode</code></pre><p>Returns the operating mode of the CachingOptimizer <code>m</code>. See <a href="#MathOptInterface.Utilities.CachingOptimizer"><code>Utilities.CachingOptimizer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/cachingoptimizer.jl#L106-L110">source</a></section></article><h2 id="Copy-utilities"><a class="docs-heading-anchor" href="#Copy-utilities">Copy utilities</a><a id="Copy-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-utilities" title="Permalink"></a></h2><p>The following utilities can be used to implement <a href="../../../reference/reference/#MathOptInterface.copy_to"><code>copy_to</code></a>. See <a href="../../../manual/implementing/#Implementing-copy">Implementing copy</a> for more details.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.automatic_copy_to" href="#MathOptInterface.Utilities.automatic_copy_to"><code>MathOptInterface.Utilities.automatic_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">automatic_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike;
                  copy_names::Bool=true,
                  filter_constraints::Union{Nothing, Function}=nothing)</code></pre><p>Use <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>Utilities.supports_default_copy_to</code></a> and <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>Utilities.supports_allocate_load</code></a> to automatically choose between <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> or <a href="#MathOptInterface.Utilities.allocate_load"><code>Utilities.allocate_load</code></a> to apply the copy operation.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L3-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.default_copy_to" href="#MathOptInterface.Utilities.default_copy_to"><code>MathOptInterface.Utilities.default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">default_copy_to(dest::MOI.ModelLike, src::MOI.ModelLike, copy_names::Bool,
                filter_constraints::Union{Nothing, Function}=nothing)</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> by adding the variables and then the constraints and attributes incrementally. The function <a href="#MathOptInterface.Utilities.supports_default_copy_to"><code>supports_default_copy_to</code></a> can be used to check whether <code>dest</code> supports the copying a model incrementally.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L598-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_default_copy_to" href="#MathOptInterface.Utilities.supports_default_copy_to"><code>MathOptInterface.Utilities.supports_default_copy_to</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_default_copy_to(model::ModelLike, copy_names::Bool)</code></pre><p>Return a <code>Bool</code> indicating whether the model <code>model</code> supports <a href="#MathOptInterface.Utilities.default_copy_to"><code>default_copy_to(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p><p>This function can be used to determine whether a model can be loaded into <code>model</code> incrementally or whether it should be cached and copied at once instead. This is used by JuMP to determine whether to add a cache or not in two situations:</p><ol><li>A first cache can be used to store the model as entered by the user as well as the names of variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>true</code>.</li><li>If bridges are used, then a second cache can be used to store the bridged model with unnamed variables and constraints. This cache is created if this function returns <code>false</code> when <code>copy_names</code> is <code>false</code>.</li></ol><p><strong>Examples</strong></p><p>If <a href="../../../reference/reference/#MathOptInterface.set"><code>MathOptInterface.set</code></a>, <a href="../../../reference/reference/#MathOptInterface.add_variable"><code>MathOptInterface.add_variable</code></a> and <a href="../../../reference/reference/#MathOptInterface.add_constraint"><code>MathOptInterface.add_constraint</code></a> are implemented for a model of type <code>MyModel</code> and names are supported, then <a href="../../../reference/reference/#MathOptInterface.copy_to"><code>MathOptInterface.copy_to</code></a> can be implemented as</p><pre><code class="language-julia">MOI.Utilities.supports_default_copy_to(model::MyModel, copy_names::Bool) = true
function MOI.copy_to(dest::MyModel, src::MOI.ModelLike; kws...)
    return MOI.Utilities.automatic_copy_to(dest, src; kws...)
end</code></pre><p>The <a href="#MathOptInterface.Utilities.automatic_copy_to"><code>Utilities.automatic_copy_to</code></a> function automatically redirects to <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a>.</p><p>If names are not supported, simply change the first line by</p><pre><code class="language-julia">MOI.supports_default_copy_to(model::MyModel, copy_names::Bool) = !copy_names</code></pre><p>The <a href="#MathOptInterface.Utilities.default_copy_to"><code>Utilities.default_copy_to</code></a> function automatically throws an helpful error in case <code>copy_to</code> is called with <code>copy_names</code> equal to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L36-L75">source</a></section></article><h3 id="allocate_load_api_ref"><a class="docs-heading-anchor" href="#allocate_load_api_ref">Allocate-Load API</a><a id="allocate_load_api_ref-1"></a><a class="docs-heading-anchor-permalink" href="#allocate_load_api_ref" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_load" href="#MathOptInterface.Utilities.allocate_load"><code>MathOptInterface.Utilities.allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_load(dest::MOI.ModelLike, src::MOI.ModelLike,
              filter_constraints::Union{Nothing, Function}=nothing
              )</code></pre><p>Implements <code>MOI.copy_to(dest, src)</code> using the Allocate-Load API. The function <a href="#MathOptInterface.Utilities.supports_allocate_load"><code>supports_allocate_load</code></a> can be used to check whether <code>dest</code> supports the Allocate-Load API.</p><p>If the <code>filter_constraints</code> arguments is given, only the constraints for which this function returns <code>true</code> will be copied. This function is given a constraint index as argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L974-L986">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_allocate_load" href="#MathOptInterface.Utilities.supports_allocate_load"><code>MathOptInterface.Utilities.supports_allocate_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_allocate_load(model::MOI.ModelLike, copy_names::Bool)::Bool</code></pre><p>Return a <code>Bool</code> indicating whether <code>model</code> supports <a href="#MathOptInterface.Utilities.allocate_load"><code>allocate_load(model, src, copy_names=copy_names)</code></a> if all the attributes set to <code>src</code> and constraints added to <code>src</code> are supported by <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L701-L707">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_variables" href="#MathOptInterface.Utilities.allocate_variables"><code>MathOptInterface.Utilities.allocate_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Creates <code>nvars</code> variables and returns a vector of <code>nvars</code> variable indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L710-L714">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate" href="#MathOptInterface.Utilities.allocate"><code>MathOptInterface.Utilities.allocate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate(model::ModelLike, attr::ModelLikeAttribute, value)
allocate(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
allocate(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>Informs <code>model</code> that <code>load</code> will be called with the same arguments after <code>load_variables</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L756-L762">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.allocate_constraint" href="#MathOptInterface.Utilities.allocate_constraint"><code>MathOptInterface.Utilities.allocate_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">allocate_constraint(model::MOI.ModelLike, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Returns the index for the constraint to be used in <code>load_constraint</code> that will be called after <code>load_variables</code> is called.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L782-L786">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_variables" href="#MathOptInterface.Utilities.load_variables"><code>MathOptInterface.Utilities.load_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_variables(model::MOI.ModelLike, nvars::Integer)</code></pre><p>Prepares <code>model</code> for <a href="#MathOptInterface.Utilities.load"><code>load</code></a> and <a href="#MathOptInterface.Utilities.load_constraint"><code>load_constraint</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L800-L804">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load" href="#MathOptInterface.Utilities.load"><code>MathOptInterface.Utilities.load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load(model::ModelLike, attr::ModelLikeAttribute, value)
load(model::ModelLike, attr::AbstractVariableAttribute, v::VariableIndex, value)
load(model::ModelLike, attr::AbstractConstraintAttribute, c::ConstraintIndex, value)</code></pre><p>This has the same effect that <code>set</code> with the same arguments except that <code>allocate</code> should be called first before <code>load_variables</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L843-L849">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.load_constraint" href="#MathOptInterface.Utilities.load_constraint"><code>MathOptInterface.Utilities.load_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">load_constraint(model::MOI.ModelLike, ci::MOI.ConstraintIndex, f::MOI.AbstractFunction, s::MOI.AbstractSet)</code></pre><p>Sets the constraint function and set for the constraint of index <code>ci</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/copy.jl#L925-L929">source</a></section></article><h2 id="Fallbacks"><a class="docs-heading-anchor" href="#Fallbacks">Fallbacks</a><a id="Fallbacks-1"></a><a class="docs-heading-anchor-permalink" href="#Fallbacks" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_fallback" href="#MathOptInterface.Utilities.get_fallback"><code>MathOptInterface.Utilities.get_fallback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_fallback(model::MOI.ModelLike, ::MOI.ObjectiveValue)</code></pre><p>Compute the objective function value using the <code>VariablePrimal</code> results and the <code>ObjectiveFunction</code> value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/results.jl#L13-L18">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.DualObjectiveValue, T::Type)::T</code></pre><p>Compute the dual objective value of type <code>T</code> using the <code>ConstraintDual</code> results and the <code>ConstraintFunction</code> and <code>ConstraintSet</code> values. Note that the nonlinear part of the model is ignored.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/results.jl#L135-L141">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, ::MOI.ConstraintPrimal,
             constraint_index::MOI.ConstraintIndex)</code></pre><p>Compute the value of the function of the constraint of index <code>constraint_index</code> using the <code>VariablePrimal</code> results and the <code>ConstraintFunction</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/results.jl#L163-L169">source</a></section><section><div><pre><code class="language-none">get_fallback(model::MOI.ModelLike, attr::MOI.ConstraintDual,
             ci::MOI.ConstraintIndex{Union{MOI.SingleVariable,
                                           MOI.VectorOfVariables}})</code></pre><p>Compute the dual of the constraint of index <code>ci</code> using the <code>ConstraintDual</code> of other constraints and the <code>ConstraintFunction</code> values. Throws an error if some constraints are quadratic or if there is one another <code>MOI.SingleVariable</code>-in-<code>S</code> or <code>MOI.VectorOfVariables</code>-in-<code>S</code> constraint with one of the variables in the function of the constraint <code>ci</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/results.jl#L473-L483">source</a></section></article><h2 id="Function-utilities"><a class="docs-heading-anchor" href="#Function-utilities">Function utilities</a><a id="Function-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Function-utilities" title="Permalink"></a></h2><p>The following utilities are available for functions:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.eval_variables" href="#MathOptInterface.Utilities.eval_variables"><code>MathOptInterface.Utilities.eval_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">eval_variables(varval::Function, f::AbstractFunction)</code></pre><p>Returns the value of function <code>f</code> if each variable index <code>vi</code> is evaluated as <code>varval(vi)</code>. Note that <code>varval</code> should return a number, see <a href="#MathOptInterface.Utilities.substitute_variables"><code>substitute_variables</code></a> for a similar function where <code>varval</code> returns a function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L6-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.map_indices" href="#MathOptInterface.Utilities.map_indices"><code>MathOptInterface.Utilities.map_indices</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">map_indices(index_map::Function, x)</code></pre><p>Substitute any <a href="../../../reference/reference/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/reference/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) in <code>x</code> by the <a href="../../../reference/reference/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> (resp. <a href="../../../reference/reference/#MathOptInterface.ConstraintIndex"><code>MOI.ConstraintIndex</code></a>) of the same type given by <code>index_map(x)</code>.</p><p>This function is used by implementations of <a href="../../../reference/reference/#MathOptInterface.copy_to"><code>MOI.copy_to</code></a> on constraint functions, attribute values and submittable values hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L66-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.substitute_variables" href="#MathOptInterface.Utilities.substitute_variables"><code>MathOptInterface.Utilities.substitute_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">substitute_variables(variable_map::Function, x)</code></pre><p>Substitute any <a href="../../../reference/reference/#MathOptInterface.VariableIndex"><code>MOI.VariableIndex</code></a> in <code>x</code> by <code>variable_map(x)</code>. The <code>variable_map</code> function returns either <a href="../../../reference/reference/#MathOptInterface.SingleVariable"><code>MOI.SingleVariable</code></a> or <a href="../../../reference/reference/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, see <a href="#MathOptInterface.Utilities.eval_variables"><code>eval_variables</code></a> for a similar function where <code>variable_map</code> returns a number.</p><p>This function is used by bridge optimizers on constraint functions, attribute values and submittable values when at least one variable bridge is used hence it needs to be implemented for custom types that are meant to be used as attribute or submittable value.</p><p>WARNING: Don&#39;t use <code>substitude_variables(::Function, ...)</code> because Julia will not specialize on this. Use instead <code>substitude_variables(::F, ...) where {F&lt;:Function}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L209-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.filter_variables" href="#MathOptInterface.Utilities.filter_variables"><code>MathOptInterface.Utilities.filter_variables</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">filter_variables(keep::Function, f::AbstractFunction)</code></pre><p>Return a new function <code>f</code> with the variable <code>vi</code> such that <code>!keep(vi)</code> removed.</p><p>WARNING: Don&#39;t define <code>filter_variables(::Function, ...)</code> because Julia will not specialize on this. Define instead <code>filter_variables(::F, ...) where {F&lt;:Function}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L958-L966">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.remove_variable" href="#MathOptInterface.Utilities.remove_variable"><code>MathOptInterface.Utilities.remove_variable</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">remove_variable(f::AbstractFunction, vi::VariableIndex)</code></pre><p>Return a new function <code>f</code> with the variable vi removed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1001-L1005">source</a></section><section><div><pre><code class="language-none">remove_variable(f::MOI.AbstractFunction, s::MOI.AbstractSet, vi::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(g, t)</code> representing the constraint <code>f</code>-in-<code>s</code> with the variable <code>vi</code> removed. That is, the terms containing the variable <code>vi</code> in the function <code>f</code> are removed and the dimension of the set <code>s</code> is updated if needed (e.g. when <code>f</code> is a <code>VectorOfVariables</code> with <code>vi</code> being one of the variables).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/model.jl#L136-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.all_coefficients" href="#MathOptInterface.Utilities.all_coefficients"><code>MathOptInterface.Utilities.all_coefficients</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">all_coefficients(p::Function, f::MOI.AbstractFunction)</code></pre><p>Determine whether predicate <code>p</code> returns <code>true</code> for all coefficients of <code>f</code>, returning <code>false</code> as soon as the first coefficient of <code>f</code> for which <code>p</code> returns <code>false</code> is encountered (short-circuiting). Similar to <code>all</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L820-L826">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.unsafe_add" href="#MathOptInterface.Utilities.unsafe_add"><code>MathOptInterface.Utilities.unsafe_add</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unsafe_add(t1::MOI.ScalarAffineTerm, t2::MOI.ScalarAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarAffineTerm</code>. It is unsafe because it uses the <code>variable_index</code> of <code>t1</code> as the <code>variable_index</code> of the output without checking that it is equal to that of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L586-L590">source</a></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.ScalarQuadraticTerm, t2::MOI.ScalarQuadraticTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.ScalarQuadraticTerm</code>. It is unsafe because it uses the <code>variable_index</code>&#39;s of <code>t1</code> as the <code>variable_index</code>&#39;s of the output without checking that they are the same (up to permutation) to those of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L598-L605">source</a></section><section><div><pre><code class="language-none">unsafe_add(t1::MOI.VectorAffineTerm, t2::MOI.VectorAffineTerm)</code></pre><p>Sums the coefficients of <code>t1</code> and <code>t2</code> and returns an output <code>MOI.VectorAffineTerm</code>. It is unsafe because it uses the <code>output_index</code> and <code>variable_index</code> of <code>t1</code> as the <code>output_index</code> and <code>variable_index</code> of the output term without checking that they are equal to those of <code>t2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L614-L618">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.isapprox_zero" href="#MathOptInterface.Utilities.isapprox_zero"><code>MathOptInterface.Utilities.isapprox_zero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isapprox_zero(f::MOI.AbstractFunction, tol)</code></pre><p>Return a <code>Bool</code> indicating whether the function <code>f</code> is approximately zero using <code>tol</code> as a tolerance.</p><p><strong>Important note</strong></p><p>This function assumes that <code>f</code> does not contain any duplicate terms, you might want to first call <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a> if that is not guaranteed. For instance, given</p><pre><code class="language-julia">f = MOI.ScalarAffineFunction(MOI.ScalarAffineTerm.([1, -1], [x, x]), 0)`.</code></pre><p>then <code>isapprox_zero(f)</code> is <code>false</code> but <code>isapprox_zero(MOIU.canonical(f))</code> is <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L839-L855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.modify_function" href="#MathOptInterface.Utilities.modify_function"><code>MathOptInterface.Utilities.modify_function</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modify_function(f::AbstractFunction, change::AbstractFunctionModification)</code></pre><p>Return a new function <code>f</code> modified according to <code>change</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1018-L1022">source</a></section></article><p>The following functions can be used to canonicalize a function:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_canonical" href="#MathOptInterface.Utilities.is_canonical"><code>MathOptInterface.Utilities.is_canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_canonical(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L629-L634">source</a></section><section><div><pre><code class="language-none">is_canonical(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns a Bool indicating whether the function is in canonical form. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L643-L648">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonical" href="#MathOptInterface.Utilities.canonical"><code>MathOptInterface.Utilities.canonical</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonical(f::Union{ScalarAffineFunction, VectorAffineFunction,
                   ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Returns the function in a canonical form, i.e.</p><ul><li>A term appear only once.</li><li>The coefficients are nonzero.</li><li>The terms appear in increasing order of variable where there the order of the variables is the order of their value.</li><li>For a <code>AbstractVectorFunction</code>, the terms are sorted in ascending order of output index.</li></ul><p>The output of <code>canonical</code> can be assumed to be a copy of <code>f</code>, even for <code>VectorOfVariables</code>.</p><p><strong>Examples</strong></p><p>If <code>x</code> (resp. <code>y</code>, <code>z</code>) is <code>VariableIndex(1)</code> (resp. 2, 3). The canonical representation of <code>ScalarAffineFunction([y, x, z, x, z], [2, 1, 3, -2, -3], 5)</code> is <code>ScalarAffineFunction([x, y], [-1, 2], 5)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L686-L702">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.canonicalize!" href="#MathOptInterface.Utilities.canonicalize!"><code>MathOptInterface.Utilities.canonicalize!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">canonicalize!(f::Union{ScalarAffineFunction, VectorAffineFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L707-L712">source</a></section><section><div><pre><code class="language-none">canonicalize!(f::Union{ScalarQuadraticFunction, VectorQuadraticFunction})</code></pre><p>Convert a function to canonical form in-place, without allocating a copy to hold the result. See <a href="#MathOptInterface.Utilities.canonical"><code>canonical</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L723-L728">source</a></section></article><p>The following functions can be used to manipulate functions with basic algebra:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.scalar_type" href="#MathOptInterface.Utilities.scalar_type"><code>MathOptInterface.Utilities.scalar_type</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">scalar_type(F::Type{&lt;:MOI.AbstractVectorFunction})</code></pre><p>Type of functions obtained by indexing objects obtained by calling <code>eachscalar</code> on functions of type <code>F</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L371-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.promote_operation" href="#MathOptInterface.Utilities.promote_operation"><code>MathOptInterface.Utilities.promote_operation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">promote_operation(op::Function, ::Type{T},
                  ArgsTypes::Type{&lt;:Union{T, MOI.AbstractFunction}}...) where T</code></pre><p>Returns the type of the <code>MOI.AbstractFunction</code> returned to the call <code>operate(op, T, args...)</code> where the types of the arguments <code>args</code> are <code>ArgsTypes</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1209-L1216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate" href="#MathOptInterface.Utilities.operate"><code>MathOptInterface.Utilities.operate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate(op::Function, ::Type{T},
        args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. No argument can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1147-L1154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate!" href="#MathOptInterface.Utilities.operate!"><code>MathOptInterface.Utilities.operate!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate!(op::Function, ::Type{T},
         args::Union{T, MOI.AbstractFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractFunction</code> representing the function resulting from the operation <code>op(args...)</code> on functions of coefficient type <code>T</code>. The first argument can be modified. The return type is the same than the method <code>operate(op, T, args...)</code> without <code>!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1166-L1174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.operate_output_index!" href="#MathOptInterface.Utilities.operate_output_index!"><code>MathOptInterface.Utilities.operate_output_index!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">operate_output_index!(
    op::Function, ::Type{T}, output_index::Integer,
    func::MOI.AbstractVectorFunction
    args::Union{T, MOI.AbstractScalarFunction}...)::MOI.AbstractFunction where T</code></pre><p>Returns an <code>MOI.AbstractVectorFunction</code> where the function at <code>output_index</code> is the result of the operation <code>op</code> applied to the function at <code>output_index</code> of <code>func</code> and <code>args</code>. The functions at output index different to <code>output_index</code> are the same as the functions at the same output index in <code>func</code>. The first argument can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L1185-L1196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.vectorize" href="#MathOptInterface.Utilities.vectorize"><code>MathOptInterface.Utilities.vectorize</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">vectorize(funcs::AbstractVector{MOI.SingleVariable})</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L2691-L2696">source</a></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarAffineFunction{T}}) where T</code></pre><p>Returns the vector of scalar affine functions in the form of a <code>MOI.VectorAffineFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L2702-L2707">source</a></section><section><div><pre><code class="language-none">vectorize(funcs::AbstractVector{MOI.ScalarQuadraticFunction{T}}) where T</code></pre><p>Returns the vector of scalar quadratic functions in the form of a <code>MOI.VectorQuadraticFunction{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/functions.jl#L2719-L2724">source</a></section></article><h2 id="Constraint-utilities"><a class="docs-heading-anchor" href="#Constraint-utilities">Constraint utilities</a><a id="Constraint-utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Constraint-utilities" title="Permalink"></a></h2><p>The following utilities are available for moving the function constant to the set for scalar constraints:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.shift_constant" href="#MathOptInterface.Utilities.shift_constant"><code>MathOptInterface.Utilities.shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">shift_constant(set::MOI.AbstractScalarSet, offset)</code></pre><p>Returns a new scalar set <code>new_set</code> such that <code>func</code>-in-<code>set</code> is equivalent to <code>func + offset</code>-in-<code>new_set</code>.</p><p>Only define this function if it makes sense to!</p><p>Use <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a> to check if the set supports shifting:</p><pre><code class="language-Julia">if supports_shift_constant(typeof(old_set))
    new_set = shift_constant(old_set, offset)
    f.constant = 0
    add_constraint(model, f, new_set)
else
    add_constraint(model, f, old_set)
end</code></pre><p>See also <a href="#MathOptInterface.Utilities.supports_shift_constant"><code>supports_shift_constant</code></a>.</p><p><strong>Examples</strong></p><p>The call <code>shift_constant(MOI.Interval(-2, 3), 1)</code> is equal to <code>MOI.Interval(-1, 4)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/sets.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.supports_shift_constant" href="#MathOptInterface.Utilities.supports_shift_constant"><code>MathOptInterface.Utilities.supports_shift_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">supports_shift_constant(::Type{S}) where {S&lt;:MOI.AbstractSet}</code></pre><p>Return <code>true</code> if <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a> is defined for set <code>S</code>.</p><p>See also <a href="#MathOptInterface.Utilities.shift_constant"><code>shift_constant</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/sets.jl#L29-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_and_add_constraint" href="#MathOptInterface.Utilities.normalize_and_add_constraint"><code>MathOptInterface.Utilities.normalize_and_add_constraint</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_and_add_constraint(model::MOI.ModelLike,
                             func::MOI.AbstractScalarFunction,
                             set::MOI.AbstractScalarSet;
                             allow_modify_function::Bool=false)</code></pre><p>Adds the scalar constraint obtained by moving the constant term in <code>func</code> to the set in <code>model</code>. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/constraints.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.normalize_constant" href="#MathOptInterface.Utilities.normalize_constant"><code>MathOptInterface.Utilities.normalize_constant</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">normalize_constant(func::MOI.AbstractScalarFunction,
                   set::MOI.AbstractScalarSet;
                   allow_modify_function::Bool=false)</code></pre><p>Return the <code>func</code>-in-<code>set</code> constraint in normalized form. That is, if <code>func</code> is <a href="../../../reference/reference/#MathOptInterface.ScalarQuadraticFunction"><code>MOI.ScalarQuadraticFunction</code></a> or <a href="../../../reference/reference/#MathOptInterface.ScalarAffineFunction"><code>MOI.ScalarAffineFunction</code></a>, the constant is moved to the set. If <code>allow_modify_function</code> is <code>true</code> then the function <code>func</code> can be modified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/constraints.jl#L29-L39">source</a></section></article><p>The following utility identifies those constraints imposing bounds on a given variable, and returns those bound values:</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.get_bounds" href="#MathOptInterface.Utilities.get_bounds"><code>MathOptInterface.Utilities.get_bounds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">get_bounds(model::MOI.ModelLike, ::Type{T}, x::MOI.VariableIndex)</code></pre><p>Return a tuple <code>(lb, ub)</code> of type <code>Tuple{T, T}</code>, where <code>lb</code> and <code>ub</code> are lower  and upper bounds, respectively, imposed on <code>x</code> in <code>model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/variables.jl#L1-L6">source</a></section></article><p>The following utilities are useful when working with symmetric matrix cones.</p><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.is_diagonal_vectorized_index" href="#MathOptInterface.Utilities.is_diagonal_vectorized_index"><code>MathOptInterface.Utilities.is_diagonal_vectorized_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_diagonal_vectorized_index(index::Base.Integer)</code></pre><p>Return whether <code>index</code> is the index of a diagonal element in a <a href="../../../reference/reference/#MathOptInterface.AbstractSymmetricMatrixSetTriangle"><code>MOI.AbstractSymmetricMatrixSetTriangle</code></a> set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/sets.jl#L65-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MathOptInterface.Utilities.side_dimension_for_vectorized_dimension" href="#MathOptInterface.Utilities.side_dimension_for_vectorized_dimension"><code>MathOptInterface.Utilities.side_dimension_for_vectorized_dimension</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">side_dimension_for_vectorized_dimension(n::Integer)</code></pre><p>Return the dimension <code>d</code> such that <code>MOI.dimension(MOI.PositiveSemidefiniteConeTriangle(d))</code> is <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jump-dev/MathOptInterface.jl/blob/5f4f75ae56bc8b5fcdb44bf8ade325606486e671/src/Utilities/sets.jl#L77-L82">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../overview/">« Overview</a><a class="docs-footer-nextpage" href="../../Test/overview/">Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 9 March 2021 23:19">Tuesday 9 March 2021</span>. Using Julia version 1.0.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
